<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fil's Unbelievable C Compiler</title>
    <link rel="stylesheet" href="/fil.css">
</head>
<body>
    <header class="header">
<h1>Fil-C</h1>

<p><em>Memory Safety</em> &bull; <em>C/C++ Compatibility</em> &bull; <em>Modern Tooling</em></p>
    </header>
    <button class="hamburger" onclick="toggleSidebar()" aria-label="Toggle navigation menu">
        <span></span>
        <span></span>
        <span></span>
    </button>
    <div class="container">
        <aside class="sidebar" id="sidebar">
<p><a href="index.html">Home</a></p>

<p><a href="installation.html">Installing</a></p>

<p><a href="documentation.html">Documentation</a></p>

<p><a href="https://github.com/pizlonator/fil-c/releases">Releases</a></p>

<p><a href="https://github.com/pizlonator/fil-c/">GitHub</a></p>

<p><a href="meet_fil.html">Meet Fil</a></p>
        </aside>
        <main class="content">
<h1>Fil's Unbelievable C Compiler</h1>

<p>Fil-C is a fork of clang 20.1.8 that includes:</p>

<ul>
<li><p>A new LLVM pass called <a href="https://github.com/pizlonator/fil-c/blob/deluge/llvm/lib/Transforms/Instrumentation/FilPizlonator.cpp"><code>llvm::FilPizlonator</code></a> that enforces <a href="gimso.html"><em>garbage in, memory safety out</em></a> semantics: either the pass will fail to generate any output (the compiler will crash), or the generated IR follows the <a href="invisicaps.html">memory safety doctrine of Fil-C</a>. So, the resulting code will get a <a href="invisicaps_by_example.html">Fil-C panic</a> if it does something that violates the rules but otherwise has identical semantics to normal C/C++.</p></li>
<li><p>Surgical changes to the clang frontend, including:</p>

<ul>
<li><p>Small changes in clang CodeGen to make the generated LLVM code consistently use the <code>ptr</code> type for pointers as well as other tweaks to make the code obey Fil-C rules. In cases where CodeGen fails to obey these rules, the Fil-C checks end up being overzealous and a perfectly valid C or C++ program might get a Fil-C panic.</p></li>
<li><p>Changes to the clang Driver to support the <a href="pizfix.html">pizfix slice</a>, <a href="optfil.html"><code>/opt/fil</code></a>, <a href="pizlix.html">Pizlix</a>, <a href="https://github.com/mbrock/filnix">filnix</a>, and <a href="https://cr.yp.to/2025/fil-c.html">filian</a>.</p></li>
<li><p>Changes to <a href="https://github.com/pizlonator/fil-c/blob/deluge/clang/lib/CodeGen/BackendUtil.cpp">BackendUtil.cpp</a> to use a Fil-C pass pipeline that invokes the <code>FilPizlonator</code>.</p></li>
</ul></li>
<li><p>Surgical changes to LLVM itself, to remove or slightly tweak optimizations that fail to follow Fil-C rules. These changes only affect passes when they run before <code>FilPizlonator</code> in the pipeline. In particular, <a href="https://github.com/pizlonator/fil-c/blob/deluge/llvm/include/llvm/IR/DataLayout.h"><code>DataLayout</code></a> has a method to detect if the IR must follow Fil-C rules.</p></li>
</ul>

<h2>The <code>FilPizlonator</code></h2>

<p>This pass applies memory safety rules <em>to every single construct in LLVM IR</em>, including:</p>

<ul>
<li><p>How values of <code>ptr</code> type are represented in SSA data flow. These get lowered to a <a href="invisicaps.html#flightptr"><em>flight pointer</em></a>: a tuple containing the lower bound pointer (which doubles as the capability object pointer) and the pointer's <em>intval</em> (i.e. raw value under the control of the C program).</p></li>
<li><p>All memory access instructions, including SIMD memory access intrinsics. Loads, stores, atomic CAS, atomic RMW, and memory transfer instructions have bounds checking prepended. Any operation that may operate on pointers (i.e. may store pointers to the heap or load pointers from the heap) is also modified to obey the <a href="invisicaps.html#restptr"><em>rest pointer</em></a> protocol.</p></li>
<li><p>All control flow instructions, including computed goto (i.e. <code>indirectbr</code>) and function calls. Function calls check that the pointer you're calling is a valid function and the calling convention is totally changed to ensure that type confusion of arguments and return values has safe outcomes.</p></li>
<li><p>All kinds of allocations (globals and <code>alloca</code>s). <code>alloca</code>s are converted to calls to <a href="fugc.html">FUGC</a> allocation APIs.</p></li>
<li><p>All linker shenanigans (including ifuncs, comdats, etc).</p></li>
<li><p>All assembly (module level and inline). In practice this means that assembly is effectively disallowed (but blank assembly idioms, which are super common, work as expected).</p></li>
<li><p>Everything else in LLVM IR.</p></li>
</ul>

<p><code>FilPizlonator</code> will turn code into an always-panic if it doesn't know how to check it. If the code is particularly evil, <code>FilPizlonator</code> will simply crash and refuse to compile.</p>

<p><code>FilPizlonator</code> also has <a href="safepoints.html">extensive support for accurate GC</a>, including:</p>

<ul>
<li><p><a href="safepoints.html#pollchecks">Inserting pollchecks at back edges</a>.</p></li>
<li><p><a href="safepoints.html#pizderson">Tracking pointers in Pizderson frames</a>. A Pizderson frame is like a <a href="https://dl.acm.org/doi/10.1145/512429.512449">Henderson frame</a> except optimized for non-moving GC. Pointer register allocation is still possible since pointers are just mirrored into Pizderson frames, as opposed to being outright stored there like a Henderson frame.</p></li>
</ul>

<p><code>FilPizlonator</code> started out as a zero-optimizations, instrument-everything-with-function-calls style, since I wasn't even sure if the technique would conceptually work out. <a href="programs_that_work.html">Since it did work out</a>, many optimizations have been added:</p>

<ul>
<li><p>Allocations and many other intrinsic operations are now inlined.</p></li>
<li><p>Bounds checks are scheduled and redundant ones are removed. (However, this is an area that could be massively improved).</p></li>
<li><p>Local variables are escape-analyzed so that those that are treated as escaping for SROA, but don't actually escape in the classic sense, are stack-allocated rather than heap-allocated.</p></li>
<li><p>Many other small optimizations.</p></li>
</ul>

<h2>Clang CodeGen Changes</h2>

<p>Clang's CodeGen module lowers the AST (abstract syntax tree) into LLVM IR. The AST still contains C/C++ types, while LLVM IR uses a lower-level type system. A key insight of Fil-C is that clang CodeGen is mostly well-behaved with respect to pointers. Values that would have been thought of as having pointer type by the C or C++ programmer (so any <code>*</code> pointer or <code>&amp;</code> reference, as well as any struct or class that contains pointers) are lowered to LLVM IR that uses the <code>ptr</code> type.</p>

<p>There are two major exceptions to this property of CodeGen, and to make Fil-C work, surgical changes had to be made to make CodeGen completely preserve pointer intent:</p>

<ul>
<li><p><code>CGAtomic</code>, the part of CodeGen that deals with atomics, normally bitcasts pointers to integers in many cases. This is mostly to address a limitation in older LLVM IR, where atomic instructions only worked on integer type. This limitation no longer holds, so the Fil-C compiler changes <code>CGAtomic</code> to use <code>ptr</code> type for pointers, just like the rest of CodeGen would.</p></li>
<li><p>C++-related lowering, for things like vtables and method pointers. This code contained many uses of integer-sized pointers to pass pointers around. This is correct in non-Fil-C LLVM IR because a pointer is nothing more than an integer. But to make C++ work with Fil-C, those uses of integer-sized pointers had to be changed to uses of <code>ptr</code>.</p></li>
</ul>

<h2>Clang Driver</h2>

<p>GCC and compatible compilers like clang have a <em>driver</em> process that takes command-line arguments from the user and transforms them into internal command-line arguments taken by the actual compiler process. The driver's responsibilities include:</p>

<ul>
<li><p>Figuring out where system headers are located (like <code>stdio.h</code> and <code>unistd.h</code>).</p></li>
<li><p>Figuring out where C++ headers are located (like <code>vector</code> and <code>thread</code>).</p></li>
<li><p>Figuring out where compiler-provided headers are located (like <code>stddef.h</code>, <code>stdatomic.h</code>, and <code>immintrin.h</code>).</p></li>
<li><p>Figuring out how to invoke the linker.</p></li>
<li><p>Figuring out where system libraries are located and how to link to them (like knowing to pass <code>-L/usr/lib -lc</code>, knowing to pass <code>-lm</code> by default for C++ builds, and knowing whether to pass <code>-lpthread</code>)</p></li>
<li><p>Figuring out where the libc-provided crt files are (like <code>crti.o</code>).</p></li>
<li><p>Figuring out where the compiler-provided crt files and builtin libraries are (like <code>crtbegin.o</code> and <code>libgcc.a</code>).</p></li>
</ul>

<p>Every operating system has opinions about these things, and the clang driver knows about the opinions of every operating system supported by clang.</p>

<p>Fil-C has its own opinions, which vary a bit depending on how the Fil-C compiler and runtime are distributed. Some things that are common across distributions:</p>

<ul>
<li><p>Fil-C requires both a yolo libc (a libc compiled with Yolo-C) and a user libc (a libc compiled with Fil-C). The yolo libc is found with <code>-lyoloc</code>.</p></li>
<li><p>Fil-C always requires the yolo libm, i.e. <code>-lyolom</code>, since the Fil-C runtime calls a few math functions.</p></li>
<li><p>Fil-C has its own runtime called <code>libpizlo.so</code>, i.e. <code>-lpizlo</code>.</p></li>
<li><p>Fil-C always uses the LLVM compiler-rt versions of crt and builtins, which ship as <code>crtbegin.o</code>, <code>crtend.o</code>, and <code>libyolort.a</code> (i.e. <code>-lyolort</code>).</p></li>
<li><p>Fil-C always links a dummy <code>libyolounwind.a</code>, i.e. <code>-lyolounwind</code>, which just contains stubs. These are only used by glibc. Because it's a static library, they only get pulled in if you do a static build and you're linking to glibc.</p></li>
<li><p>Fil-C has its own additional crt trampilines for executables, <code>filc_crt.o</code> (for normal builds) and <code>filc_mincrt.o</code> (for <code>-nodefaultlibs</code> builds).</p></li>
<li><p>Fil-C uses its own loader, called <code>ld-yolo-x86_64.so</code>.</p></li>
</ul>

<p>The clang driver contains changes to link these additional libraries and object files, as necessary.</p>

<p>Finally, depending on what kind of Fil-C distribution you are using, the driver takes different paths for working out the header file and library locations:</p>

<ul>
<li><p>In a <a href="pizfix.html">pizfix</a> distribution, all system headers and libraries are found in the <code>../../pizfix</code> directory, relative to the location of the driver's executable. All compiler-provided headers are found in <code>../lib/clang</code> relative to the driver's executable. The driver automatically puts itself in pizfix mode if it locates a <code>../../pizfix</code> directory relative to the drivers' executable.</p></li>
<li><p>In a <a href="optfil.html"><code>/opt/fil</code></a> distribution, all system and compiler headers and libraries are found in <code>/opt/fil</code>. The driver automatically puts itself in <code>/opt/fil</code> mode if it sees that the driver's executable is in <code>/opt/fil/bin</code>.</p></li>
<li><p>In a <a href="https://github.com/mbrock/filnix">filnix</a> distribution, there is a wrapper for the compiler driver that passes special arguments to specify the locations of headers and libraries.</p></li>
<li><p>In a <a href="pizlix.html">Pizlix</a> distribution, all system and compiler headers and libraries are found in system-default paths like <code>/usr/include</code> and <code>/lib</code>. The driver knows that it is in Pizlix mode if none of the other conditions hold.</p></li>
</ul>

<h2>The Fil-C Pass Pipeline</h2>

<p>Below is a graphic showing the Fil-C pass pipeline.</p>

<p><img src="llvm-pipeline.svg" class="centered-svg-60" alt="Fil-C pass pipeline"></p>

<p>Fil-C reuses the LLVM pass pipeline after <code>FilPizlonator</code>, and also runs a mini version of that pipeline before <code>FilPizlonator</code>. The pre-pizlonating passes achieve:</p>

<ul>
<li><p>Promotion of locals to registers. This is the job of passes like SROA. Note, due to clang CodeGen and SROA changes, SROA will give up on any local that has <code>union</code>-like behavior. This is why <code>FilPizlonator</code>'s escape analysis capability is so important.</p></li>
<li><p>Inlining.</p></li>
<li><p>Elimination of obviously redundant loads and stores.</p></li>
<li><p>Lots of other optimizations (like all of the ones in InstCombine).</p></li>
</ul>
        </main>
    </div>
    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const hamburger = document.querySelector('.hamburger');
            sidebar.classList.toggle('active');
            hamburger.classList.toggle('active');
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const hamburger = document.querySelector('.hamburger');
            if (window.innerWidth <= 768 && 
                !sidebar.contains(event.target) && 
                !hamburger.contains(event.target) && 
                sidebar.classList.contains('active')) {
                sidebar.classList.remove('active');
                hamburger.classList.remove('active');
            }
        });
    </script>
</body>
</html>
