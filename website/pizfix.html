<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fil-C</title>
    <link rel="stylesheet" href="/fil.css">
</head>
<body>
    <header class="header">
<h1>Fil-C</h1>

<p><em>Memory Safety</em> &bull; <em>C/C++ Compatibility</em> &bull; <em>Modern Tooling</em></p>
    </header>
    <div class="container">
        <aside class="sidebar">
<p><a href="index.html">Home</a></p>

<p><a href="installation.html">Installing</a></p>

<p><a href="documentation.html">Documentation</a></p>

<p><a href="https://github.com/pizlonator/fil-c/releases">Releases</a></p>

<p><a href="https://github.com/pizlonator/fil-c/">GitHub</a></p>
        </aside>
        <main class="content">
<h1>Pizfix: The Fil-C Staging Area</h1>

<p>Fil-C is fanatically compatible with C/C++ at the source level, but <a href="runtime.html">not compatible at all at the ABI level</a>. This means that:</p>

<ul>
<li><p>Fil-C cannot share headers with your system. You cannot <code>#include</code> anything from <code>/usr/include</code>, for example.</p></li>
<li><p>Fil-C cannot share libraries with your system. You cannot link to any thing in <code>/usr/lib</code>, for example.</p></li>
</ul>

<p>Fil-C requires its own separate <em>slice</em> of headers, libraries, and executables. This document describes the current approach (called the Pizfix) as well as two potential alternative approaches (Pizlix and <code>/opt/filc</code>).</p>

<h2>The Pizfix Slice</h2>

<p>When you <a href="installation.html">install</a> Fil-C, either from source or from binary, you will get relevant libraries, binaries, and headers in two places, assuming you unpacked Fil-C in the <code>fil-c</code> directory:</p>

<ul>
<li><p><code>fil-c/build/</code> contains clang and clang's own headers. For example, you can run clang using <code>fil-c/build/bin/clang</code> or <code>fil-c/build/bin/clang++</code>.</p></li>
<li><p><code>fil-c/pizfix/</code> contains the Fil-C system headers and libraries. For example:</p>

<ul>
<li><p><code>fil-c/pizfix/include/</code> contains libc headers.</p></li>
<li><p><code>fil-c/pizfix/stdfil-include/</code> contains Fil-C headers like <a href="stdfil.html"><code>stdfil.h</code></a> and <a href="https://github.com/pizlonator/fil-c/blob/deluge/filc/include/unwind.h"><code>unwind.h</code></a> (Fil-C has the functionality of libunwind built in).</p></li>
<li><p><code>fil-c/pizfix/os-include/</code> contains symlinks to kernel headers.</p></li>
<li><p><code>fil-c/pizfix/lib/</code> contains Fil-C <a href="runtime.html">libraries</a>, including <code>libc.so</code> and <code>libpizlo.so</code>.</p></li>
<li><p><code>fil-c/pizfix/lib_test/</code> contains a version of <code>libpizlo.so</code> that enables internal assertions. You can set <code>LD_LIBRARY_PATH</code> to point to this directory if you want to run with aggressive internal checking (which can cost a lot of perf).</p></li>
<li><p><code>fil-c/pizfix/lib_gcverify/</code> contains a version of <code>libpizlo.so</code> that has the GC verifier enabled by default. You can set <code>LD_LIBRARY_PATH</code> to point to this directory if you want to run with the verifier. The verifier makes the GC a lot slower. You can also enable the verifier with the <code>FUGC_VERIFY=1</code>, <code>FUGC_MIN_THRESHOLD=0</code>, and <code>FUGC_THRESHOLD_MULTIPLIER=1.01</code> environment variable settings. Using the library in this directory instead of environment variables is appropriate for those cases where it's easier to interpose a library than to set environment variables.</p></li>
<li><p><code>fil-c/pizfix/lib_test_gcverify/</code> contains a version of <code>libpizlo.so</code> that has internal assertions and the GC verifier enabled by default.</p></li>
</ul></li>
</ul>

<p>This allows for users to easily set up a Fil-C slice anywhere on their Linux machine, and the <a href="compiler.html">Fil-C compiler</a> and loader both search for headers and libraries in the pizfix. The compiler knows to do this by finding the pizfix relative to the location of its own binary. The clang driver is just doing this logic:</p>

<ol>
<li><p>Observe that the clang binary is at <code>filc/build/bin/clang</code>.</p></li>
<li><p>Locate clang's own headers in <code>filc/build/bin/../lib/clang/20/include</code>.</p></li>
<li><p>Locate the pizfix at <code>filc/build/bin/../../pizfix</code>.</p></li>
<li><p>Locate the headers in <code>filc/build/bin/../../pizfix/include</code>, <code>filc/build/bin/../../pizfix/stdfil-include</code>, and <code>filc/build/bin/../../pizfix/os-include</code>.</p></li>
<li><p>Locate the libraries in <code>filc/build/bin/../../pizfix/lib</code>.</p></li>
</ol>

<p>When installing additional libraries and software, it's easiest to tell the build system that <code>--prefix=fil-c/pizfix</code> - i.e. put all software in the pizfix staging area. Additionally, it's useful to build <code>pkgconf</code> and put it in the pizfix and then run all build systems with <code>PATH=fil-c/pizfix/bin:$PATH</code> so that various packages in the pizfix are able to find one another the "pkg" way.</p>

<p>Currently, the Fil-C clang will only pull this trick if it locates the pizfix. Otherwise, it will look for headers and libraries the normal Linux way (i.e. <code>/usr/include</code>, <code>/lib</code>, and <code>/usr/lib</code>). In other words, Fil-C is already set up to support being used as the primary slice of a Linux distribution with a Fil-C userland.</p>

<h2>The Pizlix Distribution</h2>

<p>One implication of Fil-C is that it is possible to build a Linux distribution where the entire userland is memory safe. Fil-C has already demonstrated sufficient compatibility with C/C++ to make this a reality. It hasn't been done yet, but it'll happen eventually. In such a distribution, there would either be no Yolo-C at all in userland, or the Yolo-C would be in a secondary slice (in some odd directory, not <code>/usr/include</code>/<code>/lib</code>/<code>/usr/lib</code>) in the same way that we currently put Fil-C in a secondary slice.</p>

<p>In Pizlix, there would be no staging area, and so the Fil-C compiler and loader would just use default Linux directories. This enables Fil-C-compiled software to just be installed with <code>--prefix/usr</code>.</p>

<p>Stay tuned for more information about Pizlix!</p>

<h2>The <code>/opt/filc</code> Slice</h2>

<p>An alternative approach to making Fil-C available to users would be to have an <code>/opt/filc</code> prefix. In this world, we would:</p>

<ul>
<li><p>Rename clang to <code>/opt/filc/bin/filcc</code>.</p></li>
<li><p>Place all of clang's headers in <code>/opt/filc/lib/clang/20/include</code>.</p></li>
<li><p>Place Fil-C system headers in <code>/opt/filc/include</code>.</p></li>
<li><p>Place Fil-C libraries in <code>/opt/filc/lib</code>.</p></li>
</ul>

<p>This would be an awesome way to distribute Fil-C, and you could set it up yourself by hacking the current Fil-C install. This is likely superior to the pizfix slice. It's complementary to the Pizlix Distribution.</p>
        </main>
    </div>
</body>
</html>
