<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fil-C</title>
    <link rel="stylesheet" href="/fil.css">
</head>
<body>
    <header class="header">
<h1>Fil-C</h1>

<p><em>Memory Safety</em> &bull; <em>C/C++ Compatibility</em> &bull; <em>Modern Tooling</em></p>
    </header>
    <div class="container">
        <aside class="sidebar">
<p><a href="index.html">Home</a></p>

<p><a href="installation.html">Installing</a></p>

<p><a href="documentation.html">Documentation</a></p>

<p><a href="https://github.com/pizlonator/fil-c/releases">Releases</a></p>

<p><a href="https://github.com/pizlonator/fil-c/">GitHub</a></p>
        </aside>
        <main class="content">
<h1>Explanation of Disassembly of a Simple Fil-C Program</h1>

<p>In this document I will explain what is going on in the machine code generated by the <a href="index.html">Fil-C</a> <a href="compiler.html">compiler</a> for the <code>insert_sorted</code> function in this simple program:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct list {
    struct list* next;
    int value;
};

__attribute__((noinline)) struct list* insert_sorted(struct list** list_head, int value)
{
    struct list* node = (struct list*)malloc(sizeof(struct list));
    node-&gt;value = value;
    struct list** next_ptr;
    for (next_ptr = list_head; ; next_ptr = &amp;(*next_ptr)-&gt;next) {
        if (!*next_ptr || (*next_ptr)-&gt;value &gt; value) {
            node-&gt;next = *next_ptr;
            *next_ptr = node;
            return node;
        }
    }
}

int main()
{
    struct list* list = NULL;
    unsigned i;
    unsigned value = 42;
    for (i = 100; i--;) {
        value ^= value &lt;&lt; 13;
        value ^= value &gt;&gt; 17;
        value ^= value &lt;&lt; 5;
        insert_sorted(&amp;list, value);
    }
    for (; list; list = list-&gt;next)
        printf("%d\n", list-&gt;value);
    return 0;
}
</code></pre>

<p>The goal of this document is to explain to you how Fil-C works today. Since it's such a young implementation, Fil-C has lots of optimization opportunities. This document links to GH issues for all of the optimization opportunities it identifies.</p>

<p>I compiled this program with my build of the Fil-C compiler (revision 61e304b42d01e3fc132dac802fe3f4b2c299653d, not for off from Fil-C release 0.668.3):</p>

<pre><code>build/bin/clang -o test43 test43.c -O2 -g
</code></pre>

<p>And then dumped the disassembly with:</p>

<pre><code>objdump -d test43
</code></pre>

<p>Here's the full disassembly of <code>insert_sorted</code>. Don't worry if you don't get it immediately; I'll explain it instruction by instruction.</p>

<pre><code>0000000000002250 &lt;pizlonated_insert_sorted&gt;:
    2250:       48 8d 05 09 00 00 00    lea    0x9(%rip),%rax        # 2260 &lt;Jf_insert_sorted&gt;
    2257:       48 8d 15 ca 29 00 00    lea    0x29ca(%rip),%rdx        # 4c28 &lt;Jfo_insert_sorted+0x10&gt;
    225e:       c3                      ret    

0000000000002260 &lt;Jf_insert_sorted&gt;:
    2260:       55                      push   %rbp
    2261:       41 57                   push   %r15
    2263:       41 56                   push   %r14
    2265:       41 55                   push   %r13
    2267:       41 54                   push   %r12
    2269:       53                      push   %rbx
    226a:       48 83 ec 58             sub    $0x58,%rsp
    226e:       48 39 27                cmp    %rsp,(%rdi)
    2271:       0f 83 e9 fd ff ff       jae    2060 &lt;filc_stack_overflow_failure@plt&gt;
    2277:       48 8b 4f 10             mov    0x10(%rdi),%rcx
    227b:       48 89 4c 24 28          mov    %rcx,0x28(%rsp)
    2280:       48 8d 4c 24 28          lea    0x28(%rsp),%rcx
    2285:       48 89 4f 10             mov    %rcx,0x10(%rdi)
    2289:       48 8d 0d d8 27 00 00    lea    0x27d8(%rip),%rcx        # 4a68 &lt;Jgo_.str+0x58&gt;
    2290:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
    2295:       0f 57 c0                xorps  %xmm0,%xmm0
    2298:       0f 11 44 24 38          movups %xmm0,0x38(%rsp)
    229d:       0f 11 44 24 48          movups %xmm0,0x48(%rsp)
    22a2:       48 83 fe 0f             cmp    $0xf,%rsi
    22a6:       0f 86 7e 04 00 00       jbe    272a &lt;Jf_insert_sorted+0x4ca&gt;
    22ac:       48 89 fb                mov    %rdi,%rbx
    22af:       4c 8b af 80 00 00 00    mov    0x80(%rdi),%r13
    22b6:       8b 87 88 00 00 00       mov    0x88(%rdi),%eax
    22bc:       89 44 24 08             mov    %eax,0x8(%rsp)
    22c0:       4c 8b a7 80 01 00 00    mov    0x180(%rdi),%r12
    22c7:       48 8d 35 02 29 00 00    lea    0x2902(%rip),%rsi        # 4bd0 &lt;Jgo_.str+0x1c0&gt;
    22ce:       e8 ed fd ff ff          call   20c0 &lt;pizlonated_malloc@plt&gt;
    22d3:       48 c7 83 80 00 00 00    movq   $0x10,0x80(%rbx)
    22da:       10 00 00 00 
    22de:       48 c7 83 80 01 00 00    movq   $0x0,0x180(%rbx)
    22e5:       00 00 00 00 
    22e9:       48 8d 0d 18 29 00 00    lea    0x2918(%rip),%rcx        # 4c08 &lt;Jgo_.str+0x1f8&gt;
    22f0:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
    22f5:       48 85 d2                test   %rdx,%rdx
    22f8:       0f 84 21 04 00 00       je     271f &lt;Jf_insert_sorted+0x4bf&gt;
    22fe:       48 8b 4a f8             mov    -0x8(%rdx),%rcx
    2302:       48 be 00 00 00 00 00    movabs $0x3c0000000000000,%rsi
    2309:       00 c0 03 
    230c:       48 21 ce                and    %rcx,%rsi
    230f:       48 bf 00 00 00 00 00    movabs $0x40000000000000,%rdi
    2316:       00 40 00 
    2319:       48 39 fe                cmp    %rdi,%rsi
    231c:       0f 85 fd 03 00 00       jne    271f &lt;Jf_insert_sorted+0x4bf&gt;
    2322:       48 be ff ff ff ff ff    movabs $0xffffffffffff,%rsi
    2329:       ff 00 00 
    232c:       48 21 f1                and    %rsi,%rcx
    232f:       48 39 c8                cmp    %rcx,%rax
    2332:       0f 85 e7 03 00 00       jne    271f &lt;Jf_insert_sorted+0x4bf&gt;
    2338:       be 08 00 00 00          mov    $0x8,%esi
    233d:       48 89 df                mov    %rbx,%rdi
    2340:       ff d0                   call   *%rax
    2342:       a8 01                   test   $0x1,%al
    2344:       0f 85 00 03 00 00       jne    264a &lt;Jf_insert_sorted+0x3ea&gt;
    234a:       48 83 fa 07             cmp    $0x7,%rdx
    234e:       0f 86 ed 03 00 00       jbe    2741 &lt;Jf_insert_sorted+0x4e1&gt;
    2354:       48 8b bb 80 00 00 00    mov    0x80(%rbx),%rdi
    235b:       48 8b b3 80 01 00 00    mov    0x180(%rbx),%rsi
    2362:       48 89 74 24 38          mov    %rsi,0x38(%rsp)
    2367:       48 85 f6                test   %rsi,%rsi
    236a:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    236f:       0f 84 b9 02 00 00       je     262e &lt;Jf_insert_sorted+0x3ce&gt;
    2375:       f6 46 fe 06             testb  $0x6,-0x2(%rsi)
    2379:       0f 85 af 02 00 00       jne    262e &lt;Jf_insert_sorted+0x3ce&gt;
    237f:       48 8d 47 08             lea    0x8(%rdi),%rax
    2383:       48 39 f0                cmp    %rsi,%rax
    2386:       0f 82 a2 02 00 00       jb     262e &lt;Jf_insert_sorted+0x3ce&gt;
    238c:       48 8b 4e f0             mov    -0x10(%rsi),%rcx
    2390:       48 83 c1 fc             add    $0xfffffffffffffffc,%rcx
    2394:       48 39 c8                cmp    %rcx,%rax
    2397:       0f 87 91 02 00 00       ja     262e &lt;Jf_insert_sorted+0x3ce&gt;
    239d:       44 89 10                mov    %r10d,(%rax)
    23a0:       4c 89 64 24 40          mov    %r12,0x40(%rsp)
    23a5:       4d 85 e4                test   %r12,%r12
    23a8:       0f 84 55 02 00 00       je     2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23ae:       49 89 f8                mov    %rdi,%r8
    23b1:       4c 8d 4e f0             lea    -0x10(%rsi),%r9
    23b5:       4c 8d 1d 9c 26 00 00    lea    0x269c(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
    23bc:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    23c3:       ff 00 00 
    23c6:       41 f6 c5 07             test   $0x7,%r13b
    23ca:       0f 85 33 02 00 00       jne    2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23d0:       4c 89 ed                mov    %r13,%rbp
    23d3:       4c 29 e5                sub    %r12,%rbp
    23d6:       0f 82 27 02 00 00       jb     2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23dc:       4d 3b 6c 24 f0          cmp    -0x10(%r12),%r13
    23e1:       0f 83 1c 02 00 00       jae    2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23e7:       49 8b 44 24 f8          mov    -0x8(%r12),%rax
    23ec:       48 21 d0                and    %rdx,%rax
    23ef:       0f 84 ba 00 00 00       je     24af &lt;Jf_insert_sorted+0x24f&gt;
    23f5:       4c 8b 3c 28             mov    (%rax,%rbp,1),%r15
    23f9:       41 f6 c7 01             test   $0x1,%r15b
    23fd:       75 67                   jne    2466 &lt;Jf_insert_sorted+0x206&gt;
    23ff:       4d 8b 75 00             mov    0x0(%r13),%r14
    2403:       4c 89 7c 24 48          mov    %r15,0x48(%rsp)
    2408:       4d 85 f6                test   %r14,%r14
    240b:       0f 84 bd 00 00 00       je     24ce &lt;Jf_insert_sorted+0x26e&gt;
    2411:       4d 85 ff                test   %r15,%r15
    2414:       0f 84 fb 01 00 00       je     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    241a:       49 8d 46 08             lea    0x8(%r14),%rax
    241e:       4c 39 f8                cmp    %r15,%rax
    2421:       0f 82 ee 01 00 00       jb     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    2427:       49 8b 4f f0             mov    -0x10(%r15),%rcx
    242b:       48 83 c1 fc             add    $0xfffffffffffffffc,%rcx
    242f:       48 39 c8                cmp    %rcx,%rax
    2432:       0f 87 dd 01 00 00       ja     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    2438:       4c 89 7c 24 50          mov    %r15,0x50(%rsp)
    243d:       44 39 10                cmp    %r10d,(%rax)
    2440:       0f 8f 2f 01 00 00       jg     2575 &lt;Jf_insert_sorted+0x315&gt;
    2446:       f6 43 08 0e             testb  $0xe,0x8(%rbx)
    244a:       75 24                   jne    2470 &lt;Jf_insert_sorted+0x210&gt;
    244c:       4c 89 7c 24 40          mov    %r15,0x40(%rsp)
    2451:       4d 89 f5                mov    %r14,%r13
    2454:       4d 89 fc                mov    %r15,%r12
    2457:       41 f6 c5 07             test   $0x7,%r13b
    245b:       0f 84 6f ff ff ff       je     23d0 &lt;Jf_insert_sorted+0x170&gt;
    2461:       e9 9d 01 00 00          jmp    2603 &lt;Jf_insert_sorted+0x3a3&gt;
    2466:       49 83 e7 fe             and    $0xfffffffffffffffe,%r15
    246a:       4d 8b 7f 08             mov    0x8(%r15),%r15
    246e:       eb 8f                   jmp    23ff &lt;Jf_insert_sorted+0x19f&gt;
    2470:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    2475:       48 89 df                mov    %rbx,%rdi
    2478:       49 89 f4                mov    %rsi,%r12
    247b:       4c 89 de                mov    %r11,%rsi
    247e:       4c 89 c5                mov    %r8,%rbp
    2481:       4d 89 cd                mov    %r9,%r13
    2484:       e8 97 fb ff ff          call   2020 &lt;filc_pollcheck_slow@plt&gt;
    2489:       4c 8d 1d c8 25 00 00    lea    0x25c8(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
    2490:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    2495:       4d 89 e9                mov    %r13,%r9
    2498:       49 89 e8                mov    %rbp,%r8
    249b:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    24a0:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    24a7:       ff 00 00 
    24aa:       4c 89 e6                mov    %r12,%rsi
    24ad:       eb 9d                   jmp    244c &lt;Jf_insert_sorted+0x1ec&gt;
    24af:       4d 8b 75 00             mov    0x0(%r13),%r14
    24b3:       48 c7 44 24 48 00 00    movq   $0x0,0x48(%rsp)
    24ba:       00 00 
    24bc:       31 c9                   xor    %ecx,%ecx
    24be:       41 bf 00 00 00 00       mov    $0x0,%r15d
    24c4:       4d 85 f6                test   %r14,%r14
    24c7:       74 08                   je     24d1 &lt;Jf_insert_sorted+0x271&gt;
    24c9:       e9 4a 01 00 00          jmp    2618 &lt;Jf_insert_sorted+0x3b8&gt;
    24ce:       4c 89 f9                mov    %r15,%rcx
    24d1:       41 f6 c0 07             test   $0x7,%r8b
    24d5:       0f 85 63 01 00 00       jne    263e &lt;Jf_insert_sorted+0x3de&gt;
    24db:       49 39 f0                cmp    %rsi,%r8
    24de:       0f 82 5a 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24e4:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    24e8:       48 0f ba e0 32          bt     $0x32,%rax
    24ed:       0f 82 4b 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24f3:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    24f9:       0f 85 b9 01 00 00       jne    26b8 &lt;Jf_insert_sorted+0x458&gt;
    24ff:       45 31 f6                xor    %r14d,%r14d
    2502:       48 21 d0                and    %rdx,%rax
    2505:       0f 84 aa 00 00 00       je     25b5 &lt;Jf_insert_sorted+0x355&gt;
    250b:       48 29 f7                sub    %rsi,%rdi
    250e:       4c 8b 0d cb 2a 00 00    mov    0x2acb(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    2515:       4d 85 ff                test   %r15,%r15
    2518:       74 0a                   je     2524 &lt;Jf_insert_sorted+0x2c4&gt;
    251a:       41 80 39 00             cmpb   $0x0,(%r9)
    251e:       0f 85 a0 01 00 00       jne    26c4 &lt;Jf_insert_sorted+0x464&gt;
    2524:       48 89 0c 38             mov    %rcx,(%rax,%rdi,1)
    2528:       4d 89 30                mov    %r14,(%r8)
    252b:       49 23 54 24 f8          and    -0x8(%r12),%rdx
    2530:       0f 84 1d 01 00 00       je     2653 &lt;Jf_insert_sorted+0x3f3&gt;
    2536:       41 80 39 00             cmpb   $0x0,(%r9)
    253a:       0f 85 4d 01 00 00       jne    268d &lt;Jf_insert_sorted+0x42d&gt;
    2540:       48 89 34 2a             mov    %rsi,(%rdx,%rbp,1)
    2544:       4d 89 45 00             mov    %r8,0x0(%r13)
    2548:       4c 89 83 80 00 00 00    mov    %r8,0x80(%rbx)
    254f:       48 89 b3 80 01 00 00    mov    %rsi,0x180(%rbx)
    2556:       ba 08 00 00 00          mov    $0x8,%edx
    255b:       31 c0                   xor    %eax,%eax
    255d:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    2562:       48 89 4b 10             mov    %rcx,0x10(%rbx)
    2566:       48 83 c4 58             add    $0x58,%rsp
    256a:       5b                      pop    %rbx
    256b:       41 5c                   pop    %r12
    256d:       41 5d                   pop    %r13
    256f:       41 5e                   pop    %r14
    2571:       41 5f                   pop    %r15
    2573:       5d                      pop    %rbp
    2574:       c3                      ret    
    2575:       41 f6 c0 07             test   $0x7,%r8b
    2579:       0f 85 2d 01 00 00       jne    26ac &lt;Jf_insert_sorted+0x44c&gt;
    257f:       49 39 f0                cmp    %rsi,%r8
    2582:       0f 82 24 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2588:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    258c:       48 0f ba e0 32          bt     $0x32,%rax
    2591:       0f 82 15 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2597:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    259d:       0f 85 70 01 00 00       jne    2713 &lt;Jf_insert_sorted+0x4b3&gt;
    25a3:       4c 89 f9                mov    %r15,%rcx
    25a6:       41 bf 01 00 00 00       mov    $0x1,%r15d
    25ac:       48 21 d0                and    %rdx,%rax
    25af:       0f 85 56 ff ff ff       jne    250b &lt;Jf_insert_sorted+0x2ab&gt;
    25b5:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    25ba:       48 8d 05 2f 25 00 00    lea    0x252f(%rip),%rax        # 4af0 &lt;Jgo_.str+0xe0&gt;
    25c1:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    25c6:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    25cb:       48 89 df                mov    %rbx,%rdi
    25ce:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    25d3:       4c 89 ce                mov    %r9,%rsi
    25d6:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    25db:       e8 20 fb ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    25e0:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    25e5:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    25ea:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    25f1:       ff 00 00 
    25f4:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    25f9:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    25fe:       e9 08 ff ff ff          jmp    250b &lt;Jf_insert_sorted+0x2ab&gt;
    2603:       48 8d 15 c6 24 00 00    lea    0x24c6(%rip),%rdx        # 4ad0 &lt;Jgo_.str+0xc0&gt;
    260a:       4c 89 ef                mov    %r13,%rdi
    260d:       4c 89 e6                mov    %r12,%rsi
    2610:       e8 db fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
    2615:       4c 89 f9                mov    %r15,%rcx
    2618:       49 83 c6 08             add    $0x8,%r14
    261c:       48 8d 15 4d 25 00 00    lea    0x254d(%rip),%rdx        # 4b70 &lt;Jgo_.str+0x160&gt;
    2623:       4c 89 f7                mov    %r14,%rdi
    2626:       48 89 ce                mov    %rcx,%rsi
    2629:       e8 c2 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
    262e:       48 83 c7 08             add    $0x8,%rdi
    2632:       48 8d 15 67 24 00 00    lea    0x2467(%rip),%rdx        # 4aa0 &lt;Jgo_.str+0x90&gt;
    2639:       e8 b2 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
    263e:       48 8d 15 cb 24 00 00    lea    0x24cb(%rip),%rdx        # 4b10 &lt;Jgo_.str+0x100&gt;
    2645:       e8 a6 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
    264a:       b0 01                   mov    $0x1,%al
    264c:       31 d2                   xor    %edx,%edx
    264e:       e9 0a ff ff ff          jmp    255d &lt;Jf_insert_sorted+0x2fd&gt;
    2653:       49 83 c4 f0             add    $0xfffffffffffffff0,%r12
    2657:       48 8d 05 d2 24 00 00    lea    0x24d2(%rip),%rax        # 4b30 &lt;Jgo_.str+0x120&gt;
    265e:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    2663:       48 89 df                mov    %rbx,%rdi
    2666:       49 89 f6                mov    %rsi,%r14
    2669:       4c 89 e6                mov    %r12,%rsi
    266c:       4d 89 c7                mov    %r8,%r15
    266f:       4d 89 cc                mov    %r9,%r12
    2672:       e8 89 fa ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    2677:       4d 89 e1                mov    %r12,%r9
    267a:       4d 89 f8                mov    %r15,%r8
    267d:       4c 89 f6                mov    %r14,%rsi
    2680:       48 89 c2                mov    %rax,%rdx
    2683:       41 80 39 00             cmpb   $0x0,(%r9)
    2687:       0f 84 b3 fe ff ff       je     2540 &lt;Jf_insert_sorted+0x2e0&gt;
    268d:       48 89 df                mov    %rbx,%rdi
    2690:       49 89 f6                mov    %rsi,%r14
    2693:       49 89 d7                mov    %rdx,%r15
    2696:       4d 89 c4                mov    %r8,%r12
    2699:       e8 02 fa ff ff          call   20a0 &lt;filc_store_barrier_for_lower_slow@plt&gt;
    269e:       4d 89 e0                mov    %r12,%r8
    26a1:       4c 89 fa                mov    %r15,%rdx
    26a4:       4c 89 f6                mov    %r14,%rsi
    26a7:       e9 94 fe ff ff          jmp    2540 &lt;Jf_insert_sorted+0x2e0&gt;
    26ac:       48 8d 15 dd 24 00 00    lea    0x24dd(%rip),%rdx        # 4b90 &lt;Jgo_.str+0x180&gt;
    26b3:       e8 38 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
    26b8:       48 8d 15 81 24 00 00    lea    0x2481(%rip),%rdx        # 4b40 &lt;Jgo_.str+0x130&gt;
    26bf:       e9 46 ff ff ff          jmp    260a &lt;Jf_insert_sorted+0x3aa&gt;
    26c4:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    26c9:       48 89 df                mov    %rbx,%rdi
    26cc:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    26d1:       48 89 ce                mov    %rcx,%rsi
    26d4:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    26d9:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    26de:       49 89 c7                mov    %rax,%r15
    26e1:       e8 ba f9 ff ff          call   20a0 &lt;filc_store_barrier_for_lower_slow@plt&gt;
    26e6:       4c 8b 0d f3 28 00 00    mov    0x28f3(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    26ed:       4c 89 f8                mov    %r15,%rax
    26f0:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    26f5:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    26fa:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    26ff:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    2706:       ff 00 00 
    2709:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    270e:       e9 11 fe ff ff          jmp    2524 &lt;Jf_insert_sorted+0x2c4&gt;
    2713:       48 8d 15 96 24 00 00    lea    0x2496(%rip),%rdx        # 4bb0 &lt;Jgo_.str+0x1a0&gt;
    271a:       e9 eb fe ff ff          jmp    260a &lt;Jf_insert_sorted+0x3aa&gt;
    271f:       48 89 c7                mov    %rax,%rdi
    2722:       48 89 d6                mov    %rdx,%rsi
    2725:       e8 b6 f9 ff ff          call   20e0 &lt;filc_check_function_call_fail@plt&gt;
    272a:       48 89 f0                mov    %rsi,%rax
    272d:       48 8d 15 34 23 00 00    lea    0x2334(%rip),%rdx        # 4a68 &lt;Jgo_.str+0x58&gt;
    2734:       be 10 00 00 00          mov    $0x10,%esi
    2739:       48 89 c7                mov    %rax,%rdi
    273c:       e8 ff f8 ff ff          call   2040 &lt;filc_cc_args_check_failure@plt&gt;
    2741:       48 8d 05 88 24 00 00    lea    0x2488(%rip),%rax        # 4bd0 &lt;Jgo_.str+0x1c0&gt;
    2748:       be 08 00 00 00          mov    $0x8,%esi
    274d:       48 89 d7                mov    %rdx,%rdi
    2750:       48 89 c2                mov    %rax,%rdx
    2753:       e8 78 f9 ff ff          call   20d0 &lt;filc_cc_rets_check_failure@plt&gt;
</code></pre>

<h1>Prologue</h1>

<p>Let's begin! First, the linker thunk:</p>

<pre><code>0000000000002250 &lt;pizlonated_insert_sorted&gt;:
    2250:       48 8d 05 09 00 00 00    lea    0x9(%rip),%rax        # 2260 &lt;Jf_insert_sorted&gt;
    2257:       48 8d 15 ca 29 00 00    lea    0x29ca(%rip),%rdx        # 4c28 &lt;Jfo_insert_sorted+0x10&gt;
    225e:       c3                      ret
</code></pre>

<p>Fil-C has memory-safe linking and puts all external symbols in the <code>pizlonated_</code> namespace. Each linker symbol (whether code or data) is a function that returns a <em>flight pointer</em> (a tuple of the pointer's capability pointer and the pointer's valkue) to the global. Here, we're returning <code>Jf_insert_sorted</code> - the actual implementation - as the pointer's value, and a pointer to a readonly internal global that represents the capability for that function. <code>Jf_insert_sorted</code> is an internal function (the linker doesn't link calls to it).</p>

<p>Next, the prologue of <code>Jf_insert_sorted</code>, which is the implementation of <code>insert_sorted</code>:</p>

<pre><code>    2260:       55                      push   %rbp
    2261:       41 57                   push   %r15
    2263:       41 56                   push   %r14
    2265:       41 55                   push   %r13
    2267:       41 54                   push   %r12
    2269:       53                      push   %rbx
    226a:       48 83 ec 58             sub    $0x58,%rsp
    226e:       48 39 27                cmp    %rsp,(%rdi)
    2271:       0f 83 e9 fd ff ff       jae    2060 &lt;filc_stack_overflow_failure@plt&gt;
</code></pre>

<p>We're saving a bunch of callee save registers using <code>push</code>, then setting up some stack space by <code>sub</code>ing from <code>%rsp</code> (the stack pointer).</p>

<p>The last two instructions - the <code>cmp</code> and <code>jae</code> - are checking if we've overflowed the stack. Here, <code>%rdi</code> is the first argument in the normal <code>X86_64</code> calling convention, which Fil-C uses to pass around the thread pointer. (<a href="https://github.com/pizlonator/fil-c/issues/16">Issue 16: Turn the thread pointer into a proper pinned register</a>). The full signature of a pizlonated function is:</p>

<pre><code>struct pizlonated_return_value {
    bool has_exception;
    size_t return_size;
};
typedef pizlonated_return_value (*pizlonated_function)(
    filc_thread* my_thread, size_t argument_size);
</code></pre>

<p>The first field in the Fil-C thread object is the stack limit. If we breach that, we jump to the special <code>filc_stack_overflow_failure</code> thunk, which is engineered to work correctly even if we had blown past the end of the stack so thoroughly that <code>%rsp</code> was no longer pointing at a valid page.</p>

<p>Next let's look a the Pizderson frame setup:</p>

<pre><code>    2277:       48 8b 4f 10             mov    0x10(%rdi),%rcx
    227b:       48 89 4c 24 28          mov    %rcx,0x28(%rsp)
    2280:       48 8d 4c 24 28          lea    0x28(%rsp),%rcx
    2285:       48 89 4f 10             mov    %rcx,0x10(%rdi)
    2289:       48 8d 0d d8 27 00 00    lea    0x27d8(%rip),%rcx        # 4a68 &lt;Jgo_.str+0x58&gt;
    2290:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
    2295:       0f 57 c0                xorps  %xmm0,%xmm0
    2298:       0f 11 44 24 38          movups %xmm0,0x38(%rsp)
    229d:       0f 11 44 24 48          movups %xmm0,0x48(%rsp)
</code></pre>

<p>Pizderson frames allow for not-too-hilariously-expensive accurate GC with minimal compiler support and a dead-simple runtime interface (i.e. how the runtime scans the stack). Pizderson frames are like <a href="https://dl.acm.org/doi/10.1145/512429.512449">Henderson frames</a> except they only support non-moving GC, which means that pointers in locals can still be register-allocated. (<a href="https://github.com/pizlonator/fil-c/issues/17">Issue 17: Implement real accurate stack scanning</a>)</p>

<p>Here's the struct layout of a Fil-C Pizderson frame:</p>

<pre><code>struct filc_frame {
    filc_frame* parent;
    const filc_origin* origin;
    void* lowers[];
};
</code></pre>

<p>In this assembly snippet, we're first setting up <code>parent</code>:</p>

<pre><code>    2277:       48 8b 4f 10             mov    0x10(%rdi),%rcx
    227b:       48 89 4c 24 28          mov    %rcx,0x28(%rsp)
</code></pre>

<p>The thread pointer (<code>%rdi</code>) has the thread pointer, and offset <code>0x10</code> happens to be where the top frame pointer field is. We load that and store it to the <code>parent</code> field of the stack-allocated <code>filc_frame</code>.</p>

<p>Then we store the address of the Pizderson frame to the top frame pointer in the thread:</p>

<pre><code>    2280:       48 8d 4c 24 28          lea    0x28(%rsp),%rcx
    2285:       48 89 4f 10             mov    %rcx,0x10(%rdi)
</code></pre>

<p>And then we store the origin (compiler-generated metadata about the a specific point in the code).</p>

<pre><code>    2289:       48 8d 0d d8 27 00 00    lea    0x27d8(%rip),%rcx        # 4a68 &lt;Jgo_.str+0x58&gt;
    2290:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
</code></pre>

<p>Note that we'll store other origins into this field. We'll do something like this store at every point in the code where we perform a call (either to the Fil-C runtime or to another pizlonated function). The origin also contains information about this function, such as the length of the <code>lowers</code> array.</p>

<p>Finally, we initialize the <code>lowers</code>.</p>

<pre><code>    2295:       0f 57 c0                xorps  %xmm0,%xmm0
    2298:       0f 11 44 24 38          movups %xmm0,0x38(%rsp)
    229d:       0f 11 44 24 48          movups %xmm0,0x48(%rsp)
</code></pre>

<p>In Fil-C runtime and compiler jargon, the <code>lower</code> is a particular representation of the capability, where we point just above the <code>filc_object</code> (i.e. the capability object), which also happens to be the lower bounds. If you see accesses at negative constant offsets as big as -16, then those are likely to be <code>filc_object</code> accesses. Since this function doesn't yet have any pointers that need to be tracked by GC, this is just initialized to zero. Whenever a pointer value is produced, it'll be stored into somewhere in this <code>lowers</code> array. (<a href="https://github.com/pizlonator/fil-c/issues/18">Issue 18: Optimize how the compiler emits stores to the filc_frame lowers array</a>)</p>

<p>Next, we process <code>insert_sorted</code>'s arguments, i.e. <code>struct list** list_head, int value</code>:</p>

<pre><code>    22a2:       48 83 fe 0f             cmp    $0xf,%rsi
    22a6:       0f 86 7e 04 00 00       jbe    272a &lt;Jf_insert_sorted+0x4ca&gt;
    22ac:       48 89 fb                mov    %rdi,%rbx
    22af:       4c 8b af 80 00 00 00    mov    0x80(%rdi),%r13
    22b6:       8b 87 88 00 00 00       mov    0x88(%rdi),%eax
    22bc:       89 44 24 08             mov    %eax,0x8(%rsp)
    22c0:       4c 8b a7 80 01 00 00    mov    0x180(%rdi),%r12
</code></pre>

<p>Recall that in the Fil-C calling convention, the second argument (<code>%rsi</code>) is the "argument size":</p>

<pre><code>typedef pizlonated_return_value (*pizlonated_function)(
    filc_thread* my_thread, size_t argument_size);
</code></pre>

<p>This is the number of bytes worth of arguments being passed. Arguments are passed in a thread-local buffer that starts at offset <code>0x80</code> from the thread pointer. Each primitive argument is passed using its corresponding 64-bit "canonical" representation (so an <code>int16_t</code> would be passed as a <code>int64_t</code> and a <code>float</code> would be passed as a <code>double</code>). Hence, <code>insert_sorted</code> takes 16 bytes worth of arguments, and this code is branching away with a <code>jbe</code> if the argument size is <code>&lt;= 0xf</code>.</p>

<p>Next it looks like we're copying the thread pointer into a callee-save register:</p>

<pre><code>    22ac:       48 89 fb                mov    %rdi,%rbx
</code></pre>

<p>And finally we're loading the arguments:</p>

<pre><code>    22af:       4c 8b af 80 00 00 00    mov    0x80(%rdi),%r13
    22b6:       8b 87 88 00 00 00       mov    0x88(%rdi),%eax
    22bc:       89 44 24 08             mov    %eax,0x8(%rsp)
    22c0:       4c 8b a7 80 01 00 00    mov    0x180(%rdi),%r12
</code></pre>

<p>Seems like one of the arguments (<code>int value</code>) is immediately spilled to <code>0x8(%rsp)</code>. Notice that there are three loads total. This is because there is a <em>second</em> buffer for the arguments' capabilities. Since <code>struct list** list_head</code> is a pointer, we load its <code>lower</code> from that buffer (at offset <code>0x180</code>).</p>

<p>Fil-C's calling convention allows for maximally sloppy function pointer casts. If the callsite's signature disagrees with the callee's signature, then stuff just tends to work. It's not clear that this is a requirement of Fil-C, and even if it was, this thread-local buffer for arguments (and return values, as we'll see later) is hilariously inefficient. (<a href="https://github.com/pizlonator/fil-c/issues/22">Issue 22: The Fil-C calling convention should be optimized</a>)</p>

<h1>Calling <code>malloc</code></h1>

<p>Next we get the pointer to <code>malloc</code>:</p>

<pre><code>    22c7:       48 8d 35 02 29 00 00    lea    0x2902(%rip),%rsi        # 4bd0 &lt;Jgo_.str+0x1c0&gt;
    22ce:       e8 ed fd ff ff          call   20c0 &lt;pizlonated_malloc@plt&gt;
</code></pre>

<p>The <code>pizlonated_malloc</code> function just returns the pointer to <code>malloc</code> along with its capability. These are now in <code>%rax</code> (the pointer) and <code>%rdx</code> (its capability; specifically, its lower).</p>

<p>The signature of a <em>pizlonated getter</em> is:</p>

<pre><code>typedef filc_ptr (*pizlonated_getter)(
    filc_thread* my_thread, const filc_origin* passed_origin);
</code></pre>

<p>In this call to <code>pizlonated_malloc</code>, we still had the thread pointer in <code>%rdi</code>, so that got passed as the first argument. And we materialized an origin and passed it as the <code>passed_origin</code> argument via <code>%rsi</code>. This is in case the getter has to be able to print a stack trace, which could happen if we're calling an <a href="https://sourceware.org/glibc/wiki/GNU_IFUNC">ifunc</a> (yes, Fil-C supports ifuncs and they are memory-safe).</p>

<p>Now we set up the arguments to the call to <code>malloc</code>. Remember, we're doing:</p>

<pre><code>    struct list* node = (struct list*)malloc(sizeof(struct list));
</code></pre>

<p><code>sizeof(struct list)</code> is 16 bytes. This is the code that passes the argument:</p>

<pre><code>    22d3:       48 c7 83 80 00 00 00    movq   $0x10,0x80(%rbx)
    22da:       10 00 00 00 
    22de:       48 c7 83 80 01 00 00    movq   $0x0,0x180(%rbx)
    22e5:       00 00 00 00
</code></pre>

<p>We're storing 16 as the argument's value, and zero as the argument's lower (since it's not a pointer). This ensures that if <code>malloc</code> was really a <code>void* (*)(void* whatever)</code>, then any accesses on <code>whatever</code> would fail due to the null capability check.</p>

<p>Next we store the <code>malloc</code> callsite's origin to our Pizderson frame:</p>

<pre><code>    22e9:       48 8d 0d 18 29 00 00    lea    0x2918(%rip),%rcx        # 4c08 &lt;Jgo_.str+0x1f8&gt;
    22f0:       48 89 4c 24 30          mov    %rcx,0x30(%rsp)
</code></pre>

<p>Then we do the function call check. This checks that the function pointer we're about to call is really pointing at a function:</p>

<pre><code>    22f5:       48 85 d2                test   %rdx,%rdx
    22f8:       0f 84 21 04 00 00       je     271f &lt;Jf_insert_sorted+0x4bf&gt;
    22fe:       48 8b 4a f8             mov    -0x8(%rdx),%rcx
    2302:       48 be 00 00 00 00 00    movabs $0x3c0000000000000,%rsi
    2309:       00 c0 03 
    230c:       48 21 ce                and    %rcx,%rsi
    230f:       48 bf 00 00 00 00 00    movabs $0x40000000000000,%rdi
    2316:       00 40 00 
    2319:       48 39 fe                cmp    %rdi,%rsi
    231c:       0f 85 fd 03 00 00       jne    271f &lt;Jf_insert_sorted+0x4bf&gt;
    2322:       48 be ff ff ff ff ff    movabs $0xffffffffffff,%rsi
    2329:       ff 00 00 
    232c:       48 21 f1                and    %rsi,%rcx
    232f:       48 39 c8                cmp    %rcx,%rax
    2332:       0f 85 e7 03 00 00       jne    271f &lt;Jf_insert_sorted+0x4bf&gt;
</code></pre>

<p>This is a super gross check! (<a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19: InvisiCaps 2.0: Remove flag bits from the aux ptr, never have null aux pointers, and stop using the low bits of lowers for atomicity tricks</a>).</p>

<p>Let's break it down. First we have to check that we don't have the null capability:</p>

<pre><code>    22f5:       48 85 d2                test   %rdx,%rdx
    22f8:       0f 84 21 04 00 00       je     271f &lt;Jf_insert_sorted+0x4bf&gt;
</code></pre>

<p>Then we have to load the aux pointer from the capability:</p>

<pre><code>    22fe:       48 8b 4a f8             mov    -0x8(%rdx),%rcx
</code></pre>

<p>This pointer has flags in the high 16 bits. First we're extracing the flag bits of interest to us into <code>%rsi</code>:</p>

<pre><code>    2302:       48 be 00 00 00 00 00    movabs $0x3c0000000000000,%rsi
    2309:       00 c0 03 
    230c:       48 21 ce                and    %rcx,%rsi
</code></pre>

<p>And then we're comparing that the flags to the value they would have for a function capability:</p>

<pre><code>    230f:       48 bf 00 00 00 00 00    movabs $0x40000000000000,%rdi
    2316:       00 40 00 
    2319:       48 39 fe                cmp    %rdi,%rsi
</code></pre>

<p>Finally, we're masking out the actual aux pointer:</p>

<pre><code>    2322:       48 be ff ff ff ff ff    movabs $0xffffffffffff,%rsi
    2329:       ff 00 00 
    232c:       48 21 f1                and    %rsi,%rcx
</code></pre>

<p>And comparing it to the function pointer:</p>

<pre><code>    232f:       48 39 c8                cmp    %rcx,%rax
    2332:       0f 85 e7 03 00 00       jne    271f &lt;Jf_insert_sorted+0x4bf&gt;
</code></pre>

<p>This ensures that the function pointer really points at the function. (<a href="https://github.com/pizlonator/fil-c/issues/20">Issue 20: Function capabilities returned from pizlonated getters are never offset</a>)</p>

<p>Finally we make the call and extract the return value:</p>

<pre><code>    2338:       be 08 00 00 00          mov    $0x8,%esi
    233d:       48 89 df                mov    %rbx,%rdi
    2340:       ff d0                   call   *%rax
    2342:       a8 01                   test   $0x1,%al
    2344:       0f 85 00 03 00 00       jne    264a &lt;Jf_insert_sorted+0x3ea&gt;
    234a:       48 83 fa 07             cmp    $0x7,%rdx
    234e:       0f 86 ed 03 00 00       jbe    2741 &lt;Jf_insert_sorted+0x4e1&gt;
    2354:       48 8b bb 80 00 00 00    mov    0x80(%rbx),%rdi
    235b:       48 8b b3 80 01 00 00    mov    0x180(%rbx),%rsi
</code></pre>

<p>The two arguments to any pizlonated function are <code>filc_thread* my_thread, size_t argument_size</code>. Here we pass 8 as the second argument (the argument size, in <code>%esi</code>), since we're only passing one primitive argument. And we pass our thread pointer as the first argument (<code>%rdi</code>). Then we actually call <code>malloc</code>:</p>

<pre><code>    2340:       ff d0                   call   *%rax
</code></pre>

<p>And check if it "threw an exception":</p>

<pre><code>    2342:       a8 01                   test   $0x1,%al
    2344:       0f 85 00 03 00 00       jne    264a &lt;Jf_insert_sorted+0x3ea&gt;
</code></pre>

<p>Pizlonated functions return the following:</p>

<pre><code>struct pizlonated_return_value {
    bool has_exception; /* returned in %rax */
    size_t return_size; /* returned in %rdx */
};
</code></pre>

<p>So, our first check is that <code>malloc</code> isn't "throwing an exception", which really means either:</p>

<ul>
<li>Phase #2 of unwinding for <code>_Unwind_RaiseException</code>, or</li>
<li>Forced unwinding <code>_Unwind_ForcedUnwind</code>.</li>
</ul>

<p>All C functions support the latter, so even C code has to defend against this. (<a href="https://github.com/pizlonator/fil-c/issues/21">Issue 21: Implement Fil-C's unwinding in terms of native unwinding</a>)</p>

<p>After that, we check that it indeed returned a value:</p>

<pre><code>    234a:       48 83 fa 07             cmp    $0x7,%rdx
    234e:       0f 86 ed 03 00 00       jbe    2741 &lt;Jf_insert_sorted+0x4e1&gt;
</code></pre>

<p>Specifically, we're branching away if the return size is <code>&lt;= 0x7</code>. And then we finish making the call by loading the returned pointer and its capability from the thread's buffer:</p>

<pre><code>    2354:       48 8b bb 80 00 00 00    mov    0x80(%rbx),%rdi
    235b:       48 8b b3 80 01 00 00    mov    0x180(%rbx),%rsi
</code></pre>

<p>The last instruction stores the <code>node</code> into the Pizderson frame:</p>

<pre><code>    2362:       48 89 74 24 38          mov    %rsi,0x38(%rsp)
</code></pre>

<p>It's pretty incredible that it takes so much work to call <code>malloc</code>. So much of this could be optimized away. But even separately from general function call optimizations, the compiler could special-case <code>malloc</code>. (<a href="https://github.com/pizlonator/fil-c/issues/23">Issue 23: Turn malloc calls into direct calls into the GC allocator</a>)</p>

<h1>Storing the <code>value</code></h1>

<p>Now we're at:</p>

<pre><code>    node-&gt;value = value;
</code></pre>

<p>This is what it takes to do that store:</p>

<pre><code>    2367:       48 85 f6                test   %rsi,%rsi
    236a:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    236f:       0f 84 b9 02 00 00       je     262e &lt;Jf_insert_sorted+0x3ce&gt;
    2375:       f6 46 fe 06             testb  $0x6,-0x2(%rsi)
    2379:       0f 85 af 02 00 00       jne    262e &lt;Jf_insert_sorted+0x3ce&gt;
    237f:       48 8d 47 08             lea    0x8(%rdi),%rax
    2383:       48 39 f0                cmp    %rsi,%rax
    2386:       0f 82 a2 02 00 00       jb     262e &lt;Jf_insert_sorted+0x3ce&gt;
    238c:       48 8b 4e f0             mov    -0x10(%rsi),%rcx
    2390:       48 83 c1 fc             add    $0xfffffffffffffffc,%rcx
    2394:       48 39 c8                cmp    %rcx,%rax
    2397:       0f 87 91 02 00 00       ja     262e &lt;Jf_insert_sorted+0x3ce&gt;
    239d:       44 89 10                mov    %r10d,(%rax)
</code></pre>

<p>First we are checking that <code>node</code>'s capability isn't null:</p>

<pre><code>    2367:       48 85 f6                test   %rsi,%rsi
    236a:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    236f:       0f 84 b9 02 00 00       je     262e &lt;Jf_insert_sorted+0x3ce&gt;
</code></pre>

<p>The compiler is being clever here, and it's interleaving the check with a fill of <code>int value</code> (it had previously been spilled at <code>0x8(%rsp)</code>).</p>

<p>Then we check that <code>node</code>'s capability is not readonly:</p>

<pre><code>    2375:       f6 46 fe 06             testb  $0x6,-0x2(%rsi)
    2379:       0f 85 af 02 00 00       jne    262e &lt;Jf_insert_sorted+0x3ce&gt;
</code></pre>

<p>Note that if we fix <a href="https://github.com/pizlonator/fil-c/issues/23">Issue 23</a> then we won't have to do most of these checks, since we'll know that the allocator returned a valid object that isn't readonly. But anyways, next we materialize <code>&amp;node-&gt;value</code> and check that it's above lower bound:</p>

<pre><code>    237f:       48 8d 47 08             lea    0x8(%rdi),%rax
    2383:       48 39 f0                cmp    %rsi,%rax
    2386:       0f 82 a2 02 00 00       jb     262e &lt;Jf_insert_sorted+0x3ce&gt;
</code></pre>

<p>Recall that capabilities are represented by the runtime and compiler using a <code>lower</code>, i.e. the lower bound, which also happens to be a pointer to the top of <code>filc_object</code>. Hence why the flag check was at <code>-0x2(%rsi)</code> and the lower bound is just <code>%rsi</code>.</p>

<p>Then we check that the upper bound minus 4 (<code>sizeof(node-&gt;value)</code>) is greater than or equal to <code>&amp;node-&gt;value</code> (and if it was below, then we branch away to a check fail).</p>

<p>Finally we store <code>value</code> into <code>node-&gt;value</code>:</p>

<pre><code>    239d:       44 89 10                mov    %r10d,(%rax)
</code></pre>

<h1>The Loop</h1>

<p>Now we're at the loop:</p>

<pre><code>    for (next_ptr = list_head; ; next_ptr = &amp;(*next_ptr)-&gt;next) {
        if (!*next_ptr || (*next_ptr)-&gt;value &gt; value) {
            node-&gt;next = *next_ptr;
            *next_ptr = node;
            return node;
        }
    }
</code></pre>

<p>But before we get into the loop body, we have the loop's pre-header (the code that executes before we start looping):</p>

<pre><code>    23a0:       4c 89 64 24 40          mov    %r12,0x40(%rsp)
    23a5:       4d 85 e4                test   %r12,%r12
    23a8:       0f 84 55 02 00 00       je     2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23ae:       49 89 f8                mov    %rdi,%r8
    23b1:       4c 8d 4e f0             lea    -0x10(%rsi),%r9
    23b5:       4c 8d 1d 9c 26 00 00    lea    0x269c(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
    23bc:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    23c3:       ff 00 00 
    23c6:       41 f6 c5 07             test   $0x7,%r13b
    23ca:       0f 85 33 02 00 00       jne    2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>The first instruction duplicates the capability of <code>list_head</code> into the Pizderson frame:</p>

<pre><code>    23a0:       4c 89 64 24 40          mov    %r12,0x40(%rsp)
</code></pre>

<p>This enables the GC to track the object. Note that this is superfluous, since the Fil-C calling convention requires that arguments are tracked by the caller. (<a href="https://github.com/pizlonator/fil-c/issues/18">Issue 18</a>)</p>

<p>Next we check that <code>list_head</code> has a valid capability:</p>

<pre><code>    23a5:       4d 85 e4                test   %r12,%r12
    23a8:       0f 84 55 02 00 00       je     2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>We make a copy of the <code>node</code> pointer:</p>

<pre><code>    23ae:       49 89 f8                mov    %rdi,%r8
</code></pre>

<p>And we save the <code>filc_object*</code> (as opposed to the <code>lower</code>) of the <code>node</code> capability into another register:</p>

<pre><code>    23b1:       4c 8d 4e f0             lea    -0x10(%rsi),%r9
</code></pre>

<p>These two instructions are almost certainly register allocation goofs on LLVM's part.</p>

<p>Then stash the origin we'll use for the pollcheck that's in the loop (I'll explain that later):</p>

<pre><code>    23b5:       4c 8d 1d 9c 26 00 00    lea    0x269c(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
</code></pre>

<p>This is totally pointless; we're taking up a perfectly good register for now good reason. (<a href="https://github.com/pizlonator/fil-c/issues/24">Issue 24: LLVM does a bad job of register allocation for origins</a>)</p>

<p>Then we stash a mask we'll use a lot:</p>

<pre><code>    23bc:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    23c3:       ff 00 00
</code></pre>

<p>We wouldn't need this mask if we removed the flags from the aux pointer in InvisiCaps. (<a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19</a>)</p>

<p>Then we check that <code>list_head</code> is pointer-aligned:</p>

<pre><code>    23c6:       41 f6 c5 07             test   $0x7,%r13b
    23ca:       0f 85 33 02 00 00       jne    2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>Now we're at the actual loop. Note that location <code>23d0</code> is the loop header (we'll branch back here). Note that <code>next_ptr = list_head</code> has implicitly happened (we're reusing the same registers that held <code>list_head</code>'s pointer value and capability to be <code>next_ptr</code>'s pointer value and capability).</p>

<pre><code>    23d0:       4c 89 ed                mov    %r13,%rbp
    23d3:       4c 29 e5                sub    %r12,%rbp
    23d6:       0f 82 27 02 00 00       jb     2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23dc:       4d 3b 6c 24 f0          cmp    -0x10(%r12),%r13
    23e1:       0f 83 1c 02 00 00       jae    2603 &lt;Jf_insert_sorted+0x3a3&gt;
    23e7:       49 8b 44 24 f8          mov    -0x8(%r12),%rax
    23ec:       48 21 d0                and    %rdx,%rax
    23ef:       0f 84 ba 00 00 00       je     24af &lt;Jf_insert_sorted+0x24f&gt;
    23f5:       4c 8b 3c 28             mov    (%rax,%rbp,1),%r15
    23f9:       41 f6 c7 01             test   $0x1,%r15b
    23fd:       75 67                   jne    2466 &lt;Jf_insert_sorted+0x206&gt;
    23ff:       4d 8b 75 00             mov    0x0(%r13),%r14
    2403:       4c 89 7c 24 48          mov    %r15,0x48(%rsp)
    2408:       4d 85 f6                test   %r14,%r14
    240b:       0f 84 bd 00 00 00       je     24ce &lt;Jf_insert_sorted+0x26e&gt;
    2411:       4d 85 ff                test   %r15,%r15
    2414:       0f 84 fb 01 00 00       je     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    241a:       49 8d 46 08             lea    0x8(%r14),%rax
    241e:       4c 39 f8                cmp    %r15,%rax
    2421:       0f 82 ee 01 00 00       jb     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    2427:       49 8b 4f f0             mov    -0x10(%r15),%rcx
    242b:       48 83 c1 fc             add    $0xfffffffffffffffc,%rcx
    242f:       48 39 c8                cmp    %rcx,%rax
    2432:       0f 87 dd 01 00 00       ja     2615 &lt;Jf_insert_sorted+0x3b5&gt;
    2438:       4c 89 7c 24 50          mov    %r15,0x50(%rsp)
    243d:       44 39 10                cmp    %r10d,(%rax)
    2440:       0f 8f 2f 01 00 00       jg     2575 &lt;Jf_insert_sorted+0x315&gt;
    2446:       f6 43 08 0e             testb  $0xe,0x8(%rbx)
    244a:       75 24                   jne    2470 &lt;Jf_insert_sorted+0x210&gt;
    244c:       4c 89 7c 24 40          mov    %r15,0x40(%rsp)
    2451:       4d 89 f5                mov    %r14,%r13
    2454:       4d 89 fc                mov    %r15,%r12
    2457:       41 f6 c5 07             test   $0x7,%r13b
    245b:       0f 84 6f ff ff ff       je     23d0 &lt;Jf_insert_sorted+0x170&gt;
    2461:       e9 9d 01 00 00          jmp    2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>The first thing the loop tries to do is to load <code>*next_ptr</code>. This requires a bunch of checks, the first of which is a lower bounds check on <code>next_ptr</code>:</p>

<pre><code>    23d0:       4c 89 ed                mov    %r13,%rbp
    23d3:       4c 29 e5                sub    %r12,%rbp
    23d6:       0f 82 27 02 00 00       jb     2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>Note that we're doing a <code>sub</code> with a branch instead of a <code>cmp</code> because we're going to need the offset from <code>next_ptr</code>'s lower bound to access the invisible capability for <code>*next_ptr</code>. So, we'll be using <code>%rbp</code> again.</p>

<p>Next we do an upper bounds check for <code>next_ptr</code>:</p>

<pre><code>    23dc:       4d 3b 6c 24 f0          cmp    -0x10(%r12),%r13
    23e1:       0f 83 1c 02 00 00       jae    2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<p>We do this upper bounds check by directly comparing to the upper bounds, which is enough to prove that <code>next_ptr</code> points to 8 bytes, since by the time we get here we would have always done an alignment check on <code>next_ptr</code> (that it's 8-byte aligned).</p>

<p>Then we load <code>next_ptr</code>'s aux pointer and check if it's not null:</p>

<pre><code>    23e7:       49 8b 44 24 f8          mov    -0x8(%r12),%rax
    23ec:       48 21 d0                and    %rdx,%rax
    23ef:       0f 84 ba 00 00 00       je     24af &lt;Jf_insert_sorted+0x24f&gt;
</code></pre>

<p>Checking if aux is not null wouldn't be necessary if we fixed InvisiCaps. (<a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19</a>) We'll need the aux pointer to load <code>*next_ptr</code>'s capability.</p>

<p>Next we load the <code>lower</code> for <code>*next_ptr</code> from its aux (<code>%rax</code> is the base of the aux allocation and <code>%rbp</code> is the offset) and check that it doesn't have the <em>atomic box</em> bit set:</p>

<pre><code>    23f5:       4c 8b 3c 28             mov    (%rax,%rbp,1),%r15
    23f9:       41 f6 c7 01             test   $0x1,%r15b
    23fd:       75 67                   jne    2466 &lt;Jf_insert_sorted+0x206&gt;
</code></pre>

<p>This check wouldn't be necessary if we fixed InvisiCaps. (<a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19</a>)</p>

<p>Now we load <code>*next_ptr</code>'s pointer value, and stash its capability in the Pizderson frame:</p>

<pre><code>    23ff:       4d 8b 75 00             mov    0x0(%r13),%r14
    2403:       4c 89 7c 24 48          mov    %r15,0x48(%rsp)
</code></pre>

<p>Now we check if <code>*next_ptr</code> is NULL:</p>

<pre><code>    2408:       4d 85 f6                test   %r14,%r14
    240b:       0f 84 bd 00 00 00       je     24ce &lt;Jf_insert_sorted+0x26e&gt;
</code></pre>

<p>If it's NULL, then we're exiting the loop, since from the compiler's standpoint, this code is not part of the loop (it's after the loop completes):</p>

<pre><code>            node-&gt;next = *next_ptr;
            *next_ptr = node;
            return node;
</code></pre>

<p>We'll get back to the machine code for this later. Inside the loop, the next thing we check (if we know that <code>*next_ptr</code> is not NULL) is <code>(*next_ptr)-&gt;value &gt; value</code>. But that requires loading <code>-&gt;value</code>, which means more safety checks.</p>

<p>The first check we need to do to load <code>(*next_ptr)-&gt;value</code> is that <code>*next_ptr</code>'s capability is valid:</p>

<pre><code>    2411:       4d 85 ff                test   %r15,%r15
    2414:       0f 84 fb 01 00 00       je     2615 &lt;Jf_insert_sorted+0x3b5&gt;
</code></pre>

<p>Then we materialize <code>&amp;(*next_ptr)-&gt;value</code> into <code>%rax</code> and check that it's above lower bound:</p>

<pre><code>    241a:       49 8d 46 08             lea    0x8(%r14),%rax
    241e:       4c 39 f8                cmp    %r15,%rax
    2421:       0f 82 ee 01 00 00       jb     2615 &lt;Jf_insert_sorted+0x3b5&gt;
</code></pre>

<p>Then we check that the upper bound is at least <code>sizeof(int)</code> above <code>&amp;(*next_ptr)-&gt;value</code>:</p>

<pre><code>    2427:       49 8b 4f f0             mov    -0x10(%r15),%rcx
    242b:       48 83 c1 fc             add    $0xfffffffffffffffc,%rcx
    242f:       48 39 c8                cmp    %rcx,%rax
    2432:       0f 87 dd 01 00 00       ja     2615 &lt;Jf_insert_sorted+0x3b5&gt;
</code></pre>

<p>It's only at this point that we save the <code>*next_ptr</code>'s capability into the Pizderson frame:</p>

<pre><code>    2438:       4c 89 7c 24 50          mov    %r15,0x50(%rsp)
</code></pre>

<p>This is not the optimal place to schedule this store, since it's only needed for the pollcheck. (<a href="https://github.com/pizlonator/fil-c/issues/18">Issue 18</a>)</p>

<p>Finally we check if <code>(*next_ptr)-&gt;value &gt; value</code>, and if it is, we exit the loop:</p>

<pre><code>    243d:       44 39 10                cmp    %r10d,(%rax)
    2440:       0f 8f 2f 01 00 00       jg     2575 &lt;Jf_insert_sorted+0x315&gt;
</code></pre>

<p>Now we do the pollcheck. Fil-C's GC uses safepointing to synchronize with the mutator, which requires the mutator to periodically execute pollchecks. Loop backedges must have pollchecks. This pollcheck ended up here:</p>

<pre><code>    2446:       f6 43 08 0e             testb  $0xe,0x8(%rbx)
    244a:       75 24                   jne    2470 &lt;Jf_insert_sorted+0x210&gt;
</code></pre>

<p>Note that there are lots of ways to optimize this check. (<a href="https://github.com/pizlonator/fil-c/issues/25">Issue 25: Optimize pollchecks</a>)</p>

<p>Now, <code>&amp;(*next_ptr)-&gt;next</code>, which happens to be exactly equal to <code>*next_ptr</code>, becomes the new <code>next_ptr</code>. Here's the code that makes that happen:</p>

<pre><code>    244c:       4c 89 7c 24 40          mov    %r15,0x40(%rsp)
    2451:       4d 89 f5                mov    %r14,%r13
    2454:       4d 89 fc                mov    %r15,%r12
</code></pre>

<p>Note that we're again saving <code>*next_ptr</code> (i.e. the new <code>next_ptr</code>) into the Pizderson frame, which is dumb. (<a href="https://github.com/pizlonator/fil-c/issues/18">Issue 18</a>)</p>

<p>Recall that at the top of the loop, <code>next_ptr</code> was in <code>%r13</code> (the pointer value) and <code>%r12</code> (the capability).</p>

<p>Finally we're doing a branch back to the top of the loop, but only if <code>next_ptr</code> is pointer-aligned. Otherwise, we branch away to code that handles that failure.</p>

<pre><code>    2457:       41 f6 c5 07             test   $0x7,%r13b
    245b:       0f 84 6f ff ff ff       je     23d0 &lt;Jf_insert_sorted+0x170&gt;
    2461:       e9 9d 01 00 00          jmp    2603 &lt;Jf_insert_sorted+0x3a3&gt;
</code></pre>

<h2>Slow Paths</h2>

<p>This loop has a number of branches that take us to slow paths, and those got scheduled after the loop.</p>

<p>The first slow path is for the case that <code>*next_ptr</code> was an atomic pointer:</p>

<pre><code>    2466:       49 83 e7 fe             and    $0xfffffffffffffffe,%r15
    246a:       4d 8b 7f 08             mov    0x8(%r15),%r15
    246e:       eb 8f                   jmp    23ff &lt;Jf_insert_sorted+0x19f&gt;
</code></pre>

<p>This extracts the capability from the atomic box and jumps back into the part of the loop right after the fast-case load of <code>*next_ptr</code>'s capability.</p>

<p>Next is the pollcheck slow path:</p>

<pre><code>    2470:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    2475:       48 89 df                mov    %rbx,%rdi
    2478:       49 89 f4                mov    %rsi,%r12
    247b:       4c 89 de                mov    %r11,%rsi
    247e:       4c 89 c5                mov    %r8,%rbp
    2481:       4d 89 cd                mov    %r9,%r13
    2484:       e8 97 fb ff ff          call   2020 &lt;filc_pollcheck_slow@plt&gt;
    2489:       4c 8d 1d c8 25 00 00    lea    0x25c8(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
    2490:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    2495:       4d 89 e9                mov    %r13,%r9
    2498:       49 89 e8                mov    %rbp,%r8
    249b:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    24a0:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    24a7:       ff 00 00 
    24aa:       4c 89 e6                mov    %r12,%rsi
    24ad:       eb 9d                   jmp    244c &lt;Jf_insert_sorted+0x1ec&gt;
</code></pre>

<p>The first instruction here saves <code>%rdi</code>, i.e. the <code>node</code> pointer, to the stack (which is weird, since it's already been replicated to <code>%r8</code>):</p>

<pre><code>    2470:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
</code></pre>

<p>Then we set up the first argument to the pollcheck, which is the thread pointer:</p>

<pre><code>    2475:       48 89 df                mov    %rbx,%rdi
</code></pre>

<p>Then we save the <code>lower</code> for <code>node</code> to a callee save:</p>

<pre><code>    2478:       49 89 f4                mov    %rsi,%r12
</code></pre>

<p>And we set up the second argument to the pollcheck, which is the origin:</p>

<pre><code>    247b:       4c 89 de                mov    %r11,%rsi
</code></pre>

<p>Finally we save <code>%r8</code> and <code>%r9</code> (a copy of <code>node</code> and its capability) to callee saves:</p>

<pre><code>    247e:       4c 89 c5                mov    %r8,%rbp
    2481:       4d 89 cd                mov    %r9,%r13
</code></pre>

<p>Note that it's silly that this code has to do so much work to save registers. It's likely that the fact that <code>filc_pollcheck_slow</code> clobbers volatile registers also prevents the register allocator from doing everything that it would like, since this save-restore logic is almost certainly due to the <a href="https://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html">greedy register allocator</a> doing live-range-splitting, and that algorithm has a limit on how much of that it will do. So, making slow paths not clobber registers would reduce code size and free up greedy's splitting budget, which could improve register allocation overall. (<a href="https://github.com/pizlonator/fil-c/issues/27">Issue 27: Slow path calls to the runtime should use a calling convention that preserves all (or most) registers</a>)</p>

<p>Then we call the pollcheck, restore everything clobbered by it, and jump back into the loop:</p>

<pre><code>    2489:       4c 8d 1d c8 25 00 00    lea    0x25c8(%rip),%r11        # 4a58 &lt;Jgo_.str+0x48&gt;
    2490:       44 8b 54 24 08          mov    0x8(%rsp),%r10d
    2495:       4d 89 e9                mov    %r13,%r9
    2498:       49 89 e8                mov    %rbp,%r8
    249b:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    24a0:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    24a7:       ff 00 00 
    24aa:       4c 89 e6                mov    %r12,%rsi
    24ad:       eb 9d                   jmp    244c &lt;Jf_insert_sorted+0x1ec&gt;
</code></pre>

<p>The next slow path code is for the case that the aux ptr of <code>next_ptr</code> was NULL:</p>

<pre><code>    24af:       4d 8b 75 00             mov    0x0(%r13),%r14
    24b3:       48 c7 44 24 48 00 00    movq   $0x0,0x48(%rsp)
    24ba:       00 00 
    24bc:       31 c9                   xor    %ecx,%ecx
    24be:       41 bf 00 00 00 00       mov    $0x0,%r15d
    24c4:       4d 85 f6                test   %r14,%r14
    24c7:       74 08                   je     24d1 &lt;Jf_insert_sorted+0x271&gt;
    24c9:       e9 4a 01 00 00          jmp    2618 &lt;Jf_insert_sorted+0x3b8&gt;
</code></pre>

<p>It's a bug that this path even exists. (<a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19</a>) Here, we do some of the same work as when we loaded <code>next_ptr</code>'s aux pointer. But, we know that the <code>lower</code> is NULL. So, we load the <code>*next_ptr</code>'s pointer value:</p>

<pre><code>    24af:       4d 8b 75 00             mov    0x0(%r13),%r14
</code></pre>

<p>Then we stash a NULL capability where we would have stashed <code>*next_ptr</code>'s capability:</p>

<pre><code>    24b3:       48 c7 44 24 48 00 00    movq   $0x0,0x48(%rsp)
    24ba:       00 00
</code></pre>

<p>This next instruction is zeroing <code>*next_ptr</code>'s capability pointer, which will be used later (and the code we branch to expects it in both <code>%rcx</code> and <code>%r15</code>):</p>

<pre><code>    24bc:       31 c9                   xor    %ecx,%ecx
    24be:       41 bf 00 00 00 00       mov    $0x0,%r15d
</code></pre>

<p>Then we check if <code>*next_ptr</code> is NULL, and if so, we branch to code that is after the loop. This is the same branch we mentioned earlier, just duplicated to this part of the code. If that branch fails, we branch out to a failure path - since we know that it's impossible to load from <code>(*next_ptr)-&gt;value</code> if <code>*next_ptr</code> has a NULL capability.</p>

<pre><code>    24c7:       74 08                   je     24d1 &lt;Jf_insert_sorted+0x271&gt;
    24c9:       e9 4a 01 00 00          jmp    2618 &lt;Jf_insert_sorted+0x3b8&gt;
</code></pre>

<h1>After The Loop</h1>

<p>This code is within the loop's scope from the standpoint of C, but it is after the loop from the standpoint of the compiler:</p>

<pre><code>            node-&gt;next = *next_ptr;
            *next_ptr = node;
            return node;
</code></pre>

<p>Here's the reason: compilers consider a <em>natural loop</em> to be all of the basic blocks backwards-reachable up to its header, from any blocks that branch to the header while being dominated by the header. This code is backwards-rachable from a <code>return</code> statement, so not something that branches to the loop header, therefore it's not part of the loop.</p>

<p>That's likely to be the primary reason why it's scheduled after the loop by the compiler.</p>

<p>What makes this code path most fun to find in the generated code is that there are multiple ways to get to it (<code>next_ptr</code> doesn't have an aux, <code>*next_ptr</code> is NULL, or <code>(*next_ptr)-&gt;value &gt; value</code>.</p>

<pre><code>    24ce:       4c 89 f9                mov    %r15,%rcx
    24d1:       41 f6 c0 07             test   $0x7,%r8b
    24d5:       0f 85 63 01 00 00       jne    263e &lt;Jf_insert_sorted+0x3de&gt;
    24db:       49 39 f0                cmp    %rsi,%r8
    24de:       0f 82 5a 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24e4:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    24e8:       48 0f ba e0 32          bt     $0x32,%rax
    24ed:       0f 82 4b 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24f3:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    24f9:       0f 85 b9 01 00 00       jne    26b8 &lt;Jf_insert_sorted+0x458&gt;
    24ff:       45 31 f6                xor    %r14d,%r14d
    2502:       48 21 d0                and    %rdx,%rax
    2505:       0f 84 aa 00 00 00       je     25b5 &lt;Jf_insert_sorted+0x355&gt;
    250b:       48 29 f7                sub    %rsi,%rdi
    250e:       4c 8b 0d cb 2a 00 00    mov    0x2acb(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    2515:       4d 85 ff                test   %r15,%r15
    2518:       74 0a                   je     2524 &lt;Jf_insert_sorted+0x2c4&gt;
    251a:       41 80 39 00             cmpb   $0x0,(%r9)
    251e:       0f 85 a0 01 00 00       jne    26c4 &lt;Jf_insert_sorted+0x464&gt;
    2524:       48 89 0c 38             mov    %rcx,(%rax,%rdi,1)
    2528:       4d 89 30                mov    %r14,(%r8)
    252b:       49 23 54 24 f8          and    -0x8(%r12),%rdx
    2530:       0f 84 1d 01 00 00       je     2653 &lt;Jf_insert_sorted+0x3f3&gt;
    2536:       41 80 39 00             cmpb   $0x0,(%r9)
    253a:       0f 85 4d 01 00 00       jne    268d &lt;Jf_insert_sorted+0x42d&gt;
    2540:       48 89 34 2a             mov    %rsi,(%rdx,%rbp,1)
    2544:       4d 89 45 00             mov    %r8,0x0(%r13)
    2548:       4c 89 83 80 00 00 00    mov    %r8,0x80(%rbx)
    254f:       48 89 b3 80 01 00 00    mov    %rsi,0x180(%rbx)
    2556:       ba 08 00 00 00          mov    $0x8,%edx
    255b:       31 c0                   xor    %eax,%eax
    255d:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    2562:       48 89 4b 10             mov    %rcx,0x10(%rbx)
    2566:       48 83 c4 58             add    $0x58,%rsp
    256a:       5b                      pop    %rbx
    256b:       41 5c                   pop    %r12
    256d:       41 5d                   pop    %r13
    256f:       41 5e                   pop    %r14
    2571:       41 5f                   pop    %r15
    2573:       5d                      pop    %rbp
    2574:       c3                      ret    
    2575:       41 f6 c0 07             test   $0x7,%r8b
    2579:       0f 85 2d 01 00 00       jne    26ac &lt;Jf_insert_sorted+0x44c&gt;
    257f:       49 39 f0                cmp    %rsi,%r8
    2582:       0f 82 24 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2588:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    258c:       48 0f ba e0 32          bt     $0x32,%rax
    2591:       0f 82 15 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2597:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    259d:       0f 85 70 01 00 00       jne    2713 &lt;Jf_insert_sorted+0x4b3&gt;
    25a3:       4c 89 f9                mov    %r15,%rcx
    25a6:       41 bf 01 00 00 00       mov    $0x1,%r15d
    25ac:       48 21 d0                and    %rdx,%rax
    25af:       0f 85 56 ff ff ff       jne    250b &lt;Jf_insert_sorted+0x2ab&gt;
    25b5:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    25ba:       48 8d 05 2f 25 00 00    lea    0x252f(%rip),%rax        # 4af0 &lt;Jgo_.str+0xe0&gt;
    25c1:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    25c6:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    25cb:       48 89 df                mov    %rbx,%rdi
    25ce:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    25d3:       4c 89 ce                mov    %r9,%rsi
    25d6:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    25db:       e8 20 fb ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    25e0:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    25e5:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    25ea:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    25f1:       ff 00 00 
    25f4:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    25f9:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    25fe:       e9 08 ff ff ff          jmp    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<p>The first instruction, <code>24ce</code>, is where we branch to if <code>*next_ptr</code> is NULL, from the normal path of the loop. The second instruction, <code>24d1</code>, is where we branch to if <code>next_ptr</code>'s aux ptr is NULL (and then the only possibility is that <code>*next_ptr</code> is NULL). And <code>2575</code> is where we branch to if <code>(*next_ptr)-&gt;value &gt; value</code>. This path is special because in this path, we would have loaded, and checked, a capability for <code>*next_ptr</code>. In the other two paths, we would have either not loaded it and inferred it to be NULL, or not checked anything about it.</p>

<p>Let's start with the first two entrypoints, since they're nearly identical:</p>

<pre><code>    24ce:       4c 89 f9                mov    %r15,%rcx
    24d1:       41 f6 c0 07             test   $0x7,%r8b
    24d5:       0f 85 63 01 00 00       jne    263e &lt;Jf_insert_sorted+0x3de&gt;
    24db:       49 39 f0                cmp    %rsi,%r8
    24de:       0f 82 5a 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24e4:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    24e8:       48 0f ba e0 32          bt     $0x32,%rax
    24ed:       0f 82 4b 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
    24f3:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    24f9:       0f 85 b9 01 00 00       jne    26b8 &lt;Jf_insert_sorted+0x458&gt;
    24ff:       45 31 f6                xor    %r14d,%r14d
    2502:       48 21 d0                and    %rdx,%rax
    2505:       0f 84 aa 00 00 00       je     25b5 &lt;Jf_insert_sorted+0x355&gt;
</code></pre>

<p>This code does some of the checks needed to execute:</p>

<pre><code>            node-&gt;next = *next_ptr;
            *next_ptr = node;
</code></pre>

<p>But under the assumption that <code>*next_ptr</code>'s pointer value is NULL. Note, this code hardly exploits this assumption. The registers are:</p>

<ul>
<li><p><code>%rcx</code> has <code>*next_ptr</code>'s capability pointer (i.e. <code>lower</code>).</p></li>
<li><p><code>%rsi</code> has <code>node</code>'s capability pointer (i.e. <code>lower</code>).</p></li>
<li><p><code>%r8</code> has <code>node</code>'s pointer value.</p></li>
<li><p><code>%r12</code> is <code>next_ptr</code>'s capability.</p></li>
<li><p><code>%r15</code> also has <code>*next_ptr</code>'s capability pointer.</p></li>
</ul>

<p>So, we start by checking that <code>node</code>'s pointer is pointer-aligned.</p>

<pre><code>    24d1:       41 f6 c0 07             test   $0x7,%r8b
    24d5:       0f 85 63 01 00 00       jne    263e &lt;Jf_insert_sorted+0x3de&gt;
</code></pre>

<p>We wouldn't have to check that if we special-cased malloc. (<a href="https://github.com/pizlonator/fil-c/issues/23">Issue 23</a>)</p>

<p>Then we check that <code>node</code> is above its lower bound.</p>

<pre><code>    24db:       49 39 f0                cmp    %rsi,%r8
    24de:       0f 82 5a 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
</code></pre>

<p>And we check if <code>node</code> isn't free.</p>

<pre><code>    24e4:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    24e8:       48 0f ba e0 32          bt     $0x32,%rax
    24ed:       0f 82 4b 01 00 00       jb     263e &lt;Jf_insert_sorted+0x3de&gt;
</code></pre>

<p>This is interesting - we could have instead checked the upper bound for <code>&amp;node-&gt;next</code>, but at this point we would have already checked the upper bound for <code>&amp;node-&gt;value</code>, which is higher. So all we really have to do is that the object hasn't been freed (we are obligated to observe it being freed across pollchecks), which is cheaper than checking the upper bound (it's just a bit test).</p>

<p>Of course, maybe this isn't actually cheaper than checking the upper bounds? (<a href="https://github.com/pizlonator/fil-c/issues/26">Issue 26: Emitting a is-not-free check instead of an upper bounds check is often a pessimization</a>)</p>

<p>Note that now, <code>%rax</code> holds the aux pointer (including its flags) for <code>node</code>.</p>

<p>Then we check if <code>*next_ptr</code> is writable, or rather that the memory pointed to by <code>next_ptr</code> doesn't have the readonly bit:</p>

<pre><code>    24f3:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    24f9:       0f 85 b9 01 00 00       jne    26b8 &lt;Jf_insert_sorted+0x458&gt;
</code></pre>

<p>Then we set <code>*next_ptr</code>'s value to NULL:</p>

<pre><code>    24ff:       45 31 f6                xor    %r14d,%r14d
</code></pre>

<p>This is because we know on this path that <code>*next_ptr</code> must be NULL. Later code will expect <code>*next_ptr</code> value to be in <code>%r14</code>, NULL or not.</p>

<p>Finally we check if <code>node</code>'s aux is not NULL (ignoring the high 16 bits):</p>

<pre><code>    2502:       48 21 d0                and    %rdx,%rax
    2505:       0f 84 aa 00 00 00       je     25b5 &lt;Jf_insert_sorted+0x355&gt;
</code></pre>

<p>We'll discuss the slow path that this goes to in a little bit. The next code is a branch destination coming from code that handles the <code>(*next_ptr)-&gt;value &gt; value</code> case.</p>

<pre><code>    250b:       48 29 f7                sub    %rsi,%rdi
    250e:       4c 8b 0d cb 2a 00 00    mov    0x2acb(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    2515:       4d 85 ff                test   %r15,%r15
    2518:       74 0a                   je     2524 &lt;Jf_insert_sorted+0x2c4&gt;
    251a:       41 80 39 00             cmpb   $0x0,(%r9)
    251e:       0f 85 a0 01 00 00       jne    26c4 &lt;Jf_insert_sorted+0x464&gt;
    2524:       48 89 0c 38             mov    %rcx,(%rax,%rdi,1)
    2528:       4d 89 30                mov    %r14,(%r8)
    252b:       49 23 54 24 f8          and    -0x8(%r12),%rdx
    2530:       0f 84 1d 01 00 00       je     2653 &lt;Jf_insert_sorted+0x3f3&gt;
    2536:       41 80 39 00             cmpb   $0x0,(%r9)
    253a:       0f 85 4d 01 00 00       jne    268d &lt;Jf_insert_sorted+0x42d&gt;
    2540:       48 89 34 2a             mov    %rsi,(%rdx,%rbp,1)
    2544:       4d 89 45 00             mov    %r8,0x0(%r13)
    2548:       4c 89 83 80 00 00 00    mov    %r8,0x80(%rbx)
    254f:       48 89 b3 80 01 00 00    mov    %rsi,0x180(%rbx)
    2556:       ba 08 00 00 00          mov    $0x8,%edx
    255b:       31 c0                   xor    %eax,%eax
    255d:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    2562:       48 89 4b 10             mov    %rcx,0x10(%rbx)
    2566:       48 83 c4 58             add    $0x58,%rsp
    256a:       5b                      pop    %rbx
    256b:       41 5c                   pop    %r12
    256d:       41 5d                   pop    %r13
    256f:       41 5e                   pop    %r14
    2571:       41 5f                   pop    %r15
    2573:       5d                      pop    %rbp
    2574:       c3                      ret
</code></pre>

<p>Let's review register state:</p>

<ul>
<li><p><code>%rax</code> has the aux pointer of <code>node</code>.</p></li>
<li><p><code>%rbx</code> is the thread pointer.</p></li>
<li><p><code>%rcx</code> has <code>*next_ptr</code>'s capability pointer (i.e. <code>lower</code>).</p></li>
<li><p><code>%rdx</code> has the <code>0xffffffffffff</code> mask (i.e. the low 48 bits mask for aux pointers).</p></li>
<li><p><code>%rbp</code> is the offset of <code>*next_ptr</code> - i.e. the pointer value minus the <code>lower</code>.</p></li>
<li><p><code>%rdi</code> has <code>node</code>'s pointer value.</p></li>
<li><p><code>%rsi</code> has <code>node</code>'s capability pointer (i.e. <code>lower</code>).</p></li>
<li><p><code>%r8</code> also has <code>node</code>'s pointer value.</p></li>
<li><p><code>%r12</code> is <code>next_ptr</code>'s capability.</p></li>
<li><p><code>%r13</code> is <code>next_ptr</code>'s pointer value.</p></li>
<li><p><code>%r14</code> has <code>*next_ptr</code>'s pointer value.</p></li>
<li><p><code>%r15</code> also has <code>*next_ptr</code>'s capability pointer, but it's only used to check if the capability is not NULL. When we come to this code from the path that handles <code>(*next_ptr)-&gt;value &gt; value</code>, <code>%r15</code> will just be 1 (so that we know that the capability isn't NULL). When we actually use the capability, we'll use <code>%rcx</code>.</p></li>
</ul>

<p>Now let's walk through this last bit of code to see what it does. First we compute the offset of the <code>node</code> pointer:</p>

<pre><code>    250b:       48 29 f7                sub    %rsi,%rdi
</code></pre>

<p>We'll need this to store to <code>node</code>'s aux, when doing <code>node-&gt;next = *next_ptr</code>. So, <code>%rdi</code> is no longer <code>node's pointer value. Luckily</code>%r8` also has the original pointer value (and we'll need it).</p>

<p>The next bit is the <em>store barrier</em> for FUGC.</p>

<pre><code>    250e:       4c 8b 0d cb 2a 00 00    mov    0x2acb(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    2515:       4d 85 ff                test   %r15,%r15
    2518:       74 0a                   je     2524 &lt;Jf_insert_sorted+0x2c4&gt;
    251a:       41 80 39 00             cmpb   $0x0,(%r9)
    251e:       0f 85 a0 01 00 00       jne    26c4 &lt;Jf_insert_sorted+0x464&gt;
</code></pre>

<p>This is what the barrier looks like in C:</p>

<pre><code>static inline void filc_store_barrier(filc_thread* my_thread, filc_object* target)
{
    if (PAS_UNLIKELY(filc_is_marking) &amp;&amp; target)
        filc_store_barrier_slow(my_thread, target);
}
</code></pre>

<p>Here, <code>target</code> is <code>%r15</code>, i.e. <code>*next_ptr</code>'s capability. First we check that it's not NULL (if it is, we skip the barrier), and then we check if <code>filc_is_marking</code> (if it is, we go to a slow path that calls <code>filc_store_barrier_slow</code>). Note we'll keep using <code>%r9</code>, because we'll have another barrier, so we'll again have to check if <code>filc_is_marking</code>. It's legal to cache this value up to any safepoint (like a call or pollcheck).</p>

<p>Then we can actually do the store for <code>node-&gt;next = *next_ptr</code>:</p>

<pre><code>    2524:       48 89 0c 38             mov    %rcx,(%rax,%rdi,1)
    2528:       4d 89 30                mov    %r14,(%r8)
</code></pre>

<p>We're storing <code>*next_ptr</code>'s capability into <code>node</code>'s aux at the offset of <code>node-&gt;next</code>, and we're storing <code>*next_ptr</code>'s pointer value into <code>node-&gt;next</code> itself.</p>

<p>Next we load <code>next_ptr</code>'s aux, mask it (<code>%rdx</code> had the mask), and check if it's NULL. If it's NULL, we jump to a slow path.</p>

<pre><code>    252b:       49 23 54 24 f8          and    -0x8(%r12),%rdx
    2530:       0f 84 1d 01 00 00       je     2653 &lt;Jf_insert_sorted+0x3f3&gt;
</code></pre>

<p>Now, <code>%rdx</code> is known to have a non-NULL aux pointer (with flags masked off) for <code>next_ptr</code>.</p>

<p>Next we check if we're marking again, because if we are, we'll have to run a barrier with <code>target</code> being <code>node</code>. We know that <code>node</code> has a non-NULL capability already.</p>

<pre><code>    2536:       41 80 39 00             cmpb   $0x0,(%r9)
    253a:       0f 85 4d 01 00 00       jne    268d &lt;Jf_insert_sorted+0x42d&gt;
</code></pre>

<p>Finally, we can do the store for <code>*next_ptr = node</code>:</p>

<pre><code>    2540:       48 89 34 2a             mov    %rsi,(%rdx,%rbp,1)
    2544:       4d 89 45 00             mov    %r8,0x0(%r13)
</code></pre>

<p>Again, since this is a pointer, we store the capability into the invisible capability location in <code>next_ptr</code>'s aux and then we store the pointer value into <code>*next_ptr</code> itself.</p>

<p>Then we set up the return value. This function returns <code>node</code>.</p>

<pre><code>    2548:       4c 89 83 80 00 00 00    mov    %r8,0x80(%rbx)
    254f:       48 89 b3 80 01 00 00    mov    %rsi,0x180(%rbx)
    2556:       ba 08 00 00 00          mov    $0x8,%edx
    255b:       31 c0                   xor    %eax,%eax
</code></pre>

<p>This returns <code>0x8</code> as the second return value (i.e. the <code>return_size</code>). And it returns <code>false</code> for the first return value (i.e. <code>has_exception</code>).</p>

<p>Finally we tear down the Pizderson frame, by retrieving the current frame's <code>parent</code> and storing it into the thread's top frame:</p>

<pre><code>    255d:       48 8b 4c 24 28          mov    0x28(%rsp),%rcx
    2562:       48 89 4b 10             mov    %rcx,0x10(%rbx)
</code></pre>

<p>And then we can actually return:</p>

<pre><code>    2566:       48 83 c4 58             add    $0x58,%rsp
    256a:       5b                      pop    %rbx
    256b:       41 5c                   pop    %r12
    256d:       41 5d                   pop    %r13
    256f:       41 5e                   pop    %r14
    2571:       41 5f                   pop    %r15
    2573:       5d                      pop    %rbp
    2574:       c3                      ret
</code></pre>

<p>But that's not all, since so far we've only covered the case where we get to this path if <code>*next_ptr</code> is NULL or if <code>next_ptr</code>'s aux ptr is NULL. Here's the code we branch to if <code>next_ptr</code> has a non-NULL aux, <code>*next_ptr</code> is not NULL, and <code>(*next_ptr)-&gt;value &gt; value</code>:</p>

<pre><code>    2575:       41 f6 c0 07             test   $0x7,%r8b
    2579:       0f 85 2d 01 00 00       jne    26ac &lt;Jf_insert_sorted+0x44c&gt;
    257f:       49 39 f0                cmp    %rsi,%r8
    2582:       0f 82 24 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2588:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    258c:       48 0f ba e0 32          bt     $0x32,%rax
    2591:       0f 82 15 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2597:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    259d:       0f 85 70 01 00 00       jne    2713 &lt;Jf_insert_sorted+0x4b3&gt;
    25a3:       4c 89 f9                mov    %r15,%rcx
    25a6:       41 bf 01 00 00 00       mov    $0x1,%r15d
    25ac:       48 21 d0                and    %rdx,%rax
    25af:       0f 85 56 ff ff ff       jne    250b &lt;Jf_insert_sorted+0x2ab&gt;
    25b5:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    25ba:       48 8d 05 2f 25 00 00    lea    0x252f(%rip),%rax        # 4af0 &lt;Jgo_.str+0xe0&gt;
    25c1:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    25c6:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    25cb:       48 89 df                mov    %rbx,%rdi
    25ce:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    25d3:       4c 89 ce                mov    %r9,%rsi
    25d6:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    25db:       e8 20 fb ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    25e0:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    25e5:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    25ea:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    25f1:       ff 00 00 
    25f4:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    25f9:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    25fe:       e9 08 ff ff ff          jmp    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<p>This code redoes much of the same checks that we did for the other entrypoints:</p>

<pre><code>    2575:       41 f6 c0 07             test   $0x7,%r8b
    2579:       0f 85 2d 01 00 00       jne    26ac &lt;Jf_insert_sorted+0x44c&gt;
    257f:       49 39 f0                cmp    %rsi,%r8
    2582:       0f 82 24 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2588:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    258c:       48 0f ba e0 32          bt     $0x32,%rax
    2591:       0f 82 15 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
    2597:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    259d:       0f 85 70 01 00 00       jne    2713 &lt;Jf_insert_sorted+0x4b3&gt;
    25a3:       4c 89 f9                mov    %r15,%rcx
    25a6:       41 bf 01 00 00 00       mov    $0x1,%r15d
    25ac:       48 21 d0                and    %rdx,%rax
    25af:       0f 85 56 ff ff ff       jne    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<p>First we check that <code>node</code>'s pointer is pointer-aligned:</p>

<pre><code>    2575:       41 f6 c0 07             test   $0x7,%r8b
    2579:       0f 85 2d 01 00 00       jne    26ac &lt;Jf_insert_sorted+0x44c&gt;
</code></pre>

<p>Then we check that <code>node</code> is above is lower bound:</p>

<pre><code>    257f:       49 39 f0                cmp    %rsi,%r8
    2582:       0f 82 24 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
</code></pre>

<p>Then we check that <code>node</code> isn't free:</p>

<pre><code>    2588:       48 8b 46 f8             mov    -0x8(%rsi),%rax
    258c:       48 0f ba e0 32          bt     $0x32,%rax
    2591:       0f 82 15 01 00 00       jb     26ac &lt;Jf_insert_sorted+0x44c&gt;
</code></pre>

<p>And if <code>*next_ptr</code> is writable:</p>

<pre><code>    2597:       41 f6 44 24 fe 02       testb  $0x2,-0x2(%r12)
    259d:       0f 85 70 01 00 00       jne    2713 &lt;Jf_insert_sorted+0x4b3&gt;
</code></pre>

<p>Now we make sure that <code>%rcx</code> has a copy of <code>*next_ptr</code>'s capability pointer.</p>

<pre><code>    25a3:       4c 89 f9                mov    %r15,%rcx
</code></pre>

<p>This next part is goofy; it's an example of how a compiler's complexity often leads to bizarre emergent behavior.</p>

<pre><code>    25a6:       41 bf 01 00 00 00       mov    $0x1,%r15d
</code></pre>

<p>Along most paths, <code>%r15</code> is <code>*next_ptr</code>'s capability pointer, and <code>%rcx</code> also has a copy of exactly the same value. We're about to branch to code that will only use <code>%r15</code> to branch on whether the capability is NULL or not. We actually know already that the capability isn't NULL. So, this sets it to 1. Note that if we removed this instruction, then nothing would change, since <code>%r15</code> is non-NULL already.</p>

<p>Then we make sure that <code>%rax</code>, which contains the aux pointer for <code>node</code>, is masked so that the high bits are zero (the flags are no longer there so the pointer can be dereferenced). Recall that we had stashed the mask in <code>%rdx</code> already. Upon masking, we branch to <code>250b</code> - i.e. the code we analyzed previously that finishes the store and returns from <code>insert_sorted</code> if the aux pointer is not NULL.</p>

<pre><code>    25ac:       48 21 d0                and    %rdx,%rax
    25af:       0f 85 56 ff ff ff       jne    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<p>If it is NULL, then we fall through to this code, which initializes the aux pointer for <code>node</code>.</p>

<pre><code>    25b5:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    25ba:       48 8d 05 2f 25 00 00    lea    0x252f(%rip),%rax        # 4af0 &lt;Jgo_.str+0xe0&gt;
    25c1:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    25c6:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    25cb:       48 89 df                mov    %rbx,%rdi
    25ce:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    25d3:       4c 89 ce                mov    %r9,%rsi
    25d6:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    25db:       e8 20 fb ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    25e0:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    25e5:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    25ea:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    25f1:       ff 00 00 
    25f4:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    25f9:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    25fe:       e9 08 ff ff ff          jmp    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<p>Most of this code is saving and restoring registers, which isn't needed if we used the right calling convention for this slow path. (<a href="https://github.com/pizlonator/fil-c/issues/27">Issue 27</a>)</p>

<p>Let's break down what's happening here. First, we save <code>%rcx</code> since we'll need it after the call returns and <code>%rcx</code> is a volatile register.</p>

<pre><code>    25b5:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
</code></pre>

<p>Then we set up the origin. This is necessary because <code>filc_object_ensure_aux_ptr_outline</code> has safety checks that may lead to the stack being dumped.</p>

<pre><code>    25ba:       48 8d 05 2f 25 00 00    lea    0x252f(%rip),%rax        # 4af0 &lt;Jgo_.str+0xe0&gt;
    25c1:       48 89 44 24 30          mov    %rax,0x30(%rsp)
</code></pre>

<p>Then next instructions save volatile registers while also setting up the arguments to <code>filc_object_ensure_aux_ptr_outline</code>:</p>

<pre><code>    25c6:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    25cb:       48 89 df                mov    %rbx,%rdi
    25ce:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    25d3:       4c 89 ce                mov    %r9,%rsi
    25d6:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
</code></pre>

<p>The first argument (<code>%rdi</code>) is the thread pointer, and the second argument (<code>%rsi</code>) is <code>node</code>'s capability, represented specifically as its <code>filc_object*</code> rather than the lower (which had previously been in <code>%r9</code>).</p>

<p>Now we can make the call, and when it returns, we restore everything we saved and jump back to <code>250b</code>, which finishes doing the stores and returns from <code>insert_sorted</code>:</p>

<pre><code>    25db:       e8 20 fb ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    25e0:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    25e5:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    25ea:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    25f1:       ff 00 00 
    25f4:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    25f9:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    25fe:       e9 08 ff ff ff          jmp    250b &lt;Jf_insert_sorted+0x2ab&gt;
</code></pre>

<h2>Slow Paths</h2>

<p>All that's left at this point are slow paths and check fail paths.</p>

<p>Let's look at a slow path that we branched to in the above code. Specifically, if <code>next_ptr</code>'s aux was NULL:</p>

<pre><code>    2653:       49 83 c4 f0             add    $0xfffffffffffffff0,%r12
    2657:       48 8d 05 d2 24 00 00    lea    0x24d2(%rip),%rax        # 4b30 &lt;Jgo_.str+0x120&gt;
    265e:       48 89 44 24 30          mov    %rax,0x30(%rsp)
    2663:       48 89 df                mov    %rbx,%rdi
    2666:       49 89 f6                mov    %rsi,%r14
    2669:       4c 89 e6                mov    %r12,%rsi
    266c:       4d 89 c7                mov    %r8,%r15
    266f:       4d 89 cc                mov    %r9,%r12
    2672:       e8 89 fa ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
    2677:       4d 89 e1                mov    %r12,%r9
    267a:       4d 89 f8                mov    %r15,%r8
    267d:       4c 89 f6                mov    %r14,%rsi
    2680:       48 89 c2                mov    %rax,%rdx
    2683:       41 80 39 00             cmpb   $0x0,(%r9)
    2687:       0f 84 b3 fe ff ff       je     2540 &lt;Jf_insert_sorted+0x2e0&gt;
    268d:       48 89 df                mov    %rbx,%rdi
    2690:       49 89 f6                mov    %rsi,%r14
    2693:       49 89 d7                mov    %rdx,%r15
    2696:       4d 89 c4                mov    %r8,%r12
    2699:       e8 02 fa ff ff          call   20a0 &lt;filc_store_barrier_for_lower_slow@plt&gt;
    269e:       4d 89 e0                mov    %r12,%r8
    26a1:       4c 89 fa                mov    %r15,%rdx
    26a4:       4c 89 f6                mov    %r14,%rsi
    26a7:       e9 94 fe ff ff          jmp    2540 &lt;Jf_insert_sorted+0x2e0&gt;
</code></pre>

<p>Again, we're calling <code>filc_object_ensure_aux_ptr_outline</code>. To do that we need to first get <code>%r12</code> - <code>next_ptr</code>'s capability - to point at the <code>filc_object</code> rather than the <code>lower, so we subtract 16 (</code>sizeof(filc_object)`):</p>

<pre><code>    2653:       49 83 c4 f0             add    $0xfffffffffffffff0,%r12
</code></pre>

<p>Then we set up the origin:</p>

<pre><code>    2657:       48 8d 05 d2 24 00 00    lea    0x24d2(%rip),%rax        # 4b30 &lt;Jgo_.str+0x120&gt;
    265e:       48 89 44 24 30          mov    %rax,0x30(%rsp)
</code></pre>

<p>And finally we save registers while setting up the first argument to be the thread and the second argument to be <code>next_ptr</code>'s object:</p>

<pre><code>    2663:       48 89 df                mov    %rbx,%rdi
    2666:       49 89 f6                mov    %rsi,%r14
    2669:       4c 89 e6                mov    %r12,%rsi
    266c:       4d 89 c7                mov    %r8,%r15
    266f:       4d 89 cc                mov    %r9,%r12
    2672:       e8 89 fa ff ff          call   2100 &lt;filc_object_ensure_aux_ptr_outline@plt&gt;
</code></pre>

<p>Then we restore registers:</p>

<pre><code>    2677:       4d 89 e1                mov    %r12,%r9
    267a:       4d 89 f8                mov    %r15,%r8
    267d:       4c 89 f6                mov    %r14,%rsi
    2680:       48 89 c2                mov    %rax,%rdx
</code></pre>

<p>We could branch back to the normal path here, but instead, the compiler chose to emit the barrier check immediately. </p>

<pre><code>    2683:       41 80 39 00             cmpb   $0x0,(%r9)
    2687:       0f 84 b3 fe ff ff       je     2540 &lt;Jf_insert_sorted+0x2e0&gt;
</code></pre>

<p>If the barrier isn't required, this branches to <code>2540</code>, which we saw previously - that's where we actually do the store for <code>*next_ptr = node</code>. If the barrier is required, then we fall through to the barrier path for that store:</p>

<pre><code>    268d:       48 89 df                mov    %rbx,%rdi
    2690:       49 89 f6                mov    %rsi,%r14
    2693:       49 89 d7                mov    %rdx,%r15
    2696:       4d 89 c4                mov    %r8,%r12
    2699:       e8 02 fa ff ff          call   20a0 &lt;filc_store_barrier_for_lower_slow@plt&gt;
    269e:       4d 89 e0                mov    %r12,%r8
    26a1:       4c 89 fa                mov    %r15,%rdx
    26a4:       4c 89 f6                mov    %r14,%rsi
    26a7:       e9 94 fe ff ff          jmp    2540 &lt;Jf_insert_sorted+0x2e0&gt;
</code></pre>

<p>The signature of <code>filc_store_barrier_for_lower_slow</code> is:</p>

<pre><code>void filc_store_barrier_for_lower_slow(filc_thread* my_thread, void* lower);
</code></pre>

<p>So, we're moving the thread pointer into the first argument (<code>%rdi</code>) and the <code>%rsi</code> already had the capability for <code>node</code>.</p>

<p>And then there's another store barrier slow path, this time for <code>node-&gt;next = *next_ptr</code>:</p>

<pre><code>    26c4:       48 89 7c 24 10          mov    %rdi,0x10(%rsp)
    26c9:       48 89 df                mov    %rbx,%rdi
    26cc:       48 89 74 24 08          mov    %rsi,0x8(%rsp)
    26d1:       48 89 ce                mov    %rcx,%rsi
    26d4:       4c 89 44 24 20          mov    %r8,0x20(%rsp)
    26d9:       48 89 4c 24 18          mov    %rcx,0x18(%rsp)
    26de:       49 89 c7                mov    %rax,%r15
    26e1:       e8 ba f9 ff ff          call   20a0 &lt;filc_store_barrier_for_lower_slow@plt&gt;
    26e6:       4c 8b 0d f3 28 00 00    mov    0x28f3(%rip),%r9        # 4fe0 &lt;filc_is_marking&gt;
    26ed:       4c 89 f8                mov    %r15,%rax
    26f0:       48 8b 4c 24 18          mov    0x18(%rsp),%rcx
    26f5:       4c 8b 44 24 20          mov    0x20(%rsp),%r8
    26fa:       48 8b 7c 24 10          mov    0x10(%rsp),%rdi
    26ff:       48 ba ff ff ff ff ff    movabs $0xffffffffffff,%rdx
    2706:       ff 00 00 
    2709:       48 8b 74 24 08          mov    0x8(%rsp),%rsi
    270e:       e9 11 fe ff ff          jmp    2524 &lt;Jf_insert_sorted+0x2c4&gt;
</code></pre>

<p>Lots of the code for these slow paths would go away if we used the right calling convention for runtime calls. (<a href="https://github.com/pizlonator/fil-c/issues/27">Issue 27</a>)</p>

<h1>Check Failures</h1>

<p>This path handles a total of 6 check failures, all to do with <code>next_ptr</code> and <code>list_head</code>:</p>

<pre><code>    2603:       48 8d 15 c6 24 00 00    lea    0x24c6(%rip),%rdx        # 4ad0 &lt;Jgo_.str+0xc0&gt;
    260a:       4c 89 ef                mov    %r13,%rdi
    260d:       4c 89 e6                mov    %r12,%rsi
    2610:       e8 db fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
</code></pre>

<p>All but one branches to this go to <code>2603</code>, but one branch here goes to <code>260a</code> (in that case, a different origin is supplied).</p>

<p>Here's the signature of <code>filc_optimized_access_check_fail</code>:</p>

<pre><code>PAS_NEVER_INLINE PAS_NO_RETURN void filc_optimized_access_check_fail(
    filc_ptr ptr, const filc_optimized_access_check_origin* check_origin);
</code></pre>

<p>So, this is a tail call, and the first argument (passed in <code>%rdi</code> and <code>%rsi</code>) is the pointer that caused the failure (<code>next_ptr</code>/<code>list_head</code> here) while the second argument (passed in <code>%rdx</code>) is a compiler-generated constant global data object that provides the runtime with the metadata necessary to describe the failure.</p>

<p>Next up, this code has two entrypoints handling four total failures:</p>

<pre><code>    2615:       4c 89 f9                mov    %r15,%rcx
    2618:       49 83 c6 08             add    $0x8,%r14
    261c:       48 8d 15 4d 25 00 00    lea    0x254d(%rip),%rdx        # 4b70 &lt;Jgo_.str+0x160&gt;
    2623:       4c 89 f7                mov    %r14,%rdi
    2626:       48 89 ce                mov    %rcx,%rsi
    2629:       e8 c2 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
</code></pre>

<p>Three branches go to <code>2615</code> and one branch goes to <code>2618</code>. All of them have to do with checking <code>*next_ptr</code>.</p>

<p>Now we handle four different check failures to do with <code>node</code>:</p>

<pre><code>    262e:       48 83 c7 08             add    $0x8,%rdi
    2632:       48 8d 15 67 24 00 00    lea    0x2467(%rip),%rdx        # 4aa0 &lt;Jgo_.str+0x90&gt;
    2639:       e8 b2 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
</code></pre>

<p>Now we handle three other check failures for <code>node</code>, this time when storing to <code>node-&gt;next</code>:</p>

<pre><code>    263e:       48 8d 15 cb 24 00 00    lea    0x24cb(%rip),%rdx        # 4b10 &lt;Jgo_.str+0x100&gt;
    2645:       e8 a6 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
</code></pre>

<p>It's possible that <code>malloc</code> "threw an exception", in which case we just propagate it. If the exception check after the <code>malloc</code> call detects this, we branch here. This sets the return value to <code>has_exception = true</code> and <code>return_size = 0</code>, and then jumps to the return path:</p>

<pre><code>    264a:       b0 01                   mov    $0x1,%al
    264c:       31 d2                   xor    %edx,%edx
    264e:       e9 0a ff ff ff          jmp    255d &lt;Jf_insert_sorted+0x2fd&gt;
</code></pre>

<p>This services three different check failures, all to do with <code>node</code>:</p>

<pre><code>    26ac:       48 8d 15 dd 24 00 00    lea    0x24dd(%rip),%rdx        # 4b90 &lt;Jgo_.str+0x180&gt;
    26b3:       e8 38 fa ff ff          call   20f0 &lt;filc_optimized_access_check_fail@plt&gt;
</code></pre>

<p>Note that this expects <code>%rdi</code>/<code>%rsi</code> to already have <code>node</code>'s pointer and capability.</p>

<p>And then this handles exactly one failure, to do with <code>*next_ptr</code>:</p>

<pre><code>    26b8:       48 8d 15 81 24 00 00    lea    0x2481(%rip),%rdx        # 4b40 &lt;Jgo_.str+0x130&gt;
    26bf:       e9 46 ff ff ff          jmp    260a &lt;Jf_insert_sorted+0x3aa&gt;
</code></pre>

<p>We're just setting up the origin and jumping to code that handles the rest of the code for calling <code>filc_optimized_access_check_fail</code>.</p>

<p>The function call to <code>malloc</code> might fail because <code>malloc</code> wasn't a function pointer; those three check failures go here:</p>

<pre><code>    271f:       48 89 c7                mov    %rax,%rdi
    2722:       48 89 d6                mov    %rdx,%rsi
    2725:       e8 b6 f9 ff ff          call   20e0 &lt;filc_check_function_call_fail@plt&gt;
</code></pre>

<p>Then there's the case where <code>insert_sorted</code> was not passed enough arguments; that one check goes here:</p>

<pre><code>    272a:       48 89 f0                mov    %rsi,%rax
    272d:       48 8d 15 34 23 00 00    lea    0x2334(%rip),%rdx        # 4a68 &lt;Jgo_.str+0x58&gt;
    2734:       be 10 00 00 00          mov    $0x10,%esi
    2739:       48 89 c7                mov    %rax,%rdi
    273c:       e8 ff f8 ff ff          call   2040 &lt;filc_cc_args_check_failure@plt&gt;
</code></pre>

<p>And finally there's the case where <code>malloc</code> didn't return a value; that one check failure goes here:</p>

<pre><code>    2741:       48 8d 05 88 24 00 00    lea    0x2488(%rip),%rax        # 4bd0 &lt;Jgo_.str+0x1c0&gt;
    2748:       be 08 00 00 00          mov    $0x8,%esi
    274d:       48 89 d7                mov    %rdx,%rdi
    2750:       48 89 c2                mov    %rax,%rdx
    2753:       e8 78 f9 ff ff          call   20d0 &lt;filc_cc_rets_check_failure@plt&gt;
</code></pre>

<h1>Conclusion</h1>

<p>Fil-C can compile C in a way that makes the code memory-safe. This post shows how Fil-C is very comprehensive in the checking it emits. Analyzing that code shows lots of room for improvement. I filed the following issues by doing this exercise:</p>

<ul>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/16">Issue 16: Turn the thread pointer into a proper pinned register</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/17">Issue 17: Implement real accurate stack scanning</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/18">Issue 18: Optimize how the compiler emits stores to the filc_frame lowers array</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/19">Issue 19: InvisiCaps 2.0: Remove flag bits from the aux ptr, never have null aux pointers, and stop using the low bits of lowers for atomicity tricks</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/20">Issue 20: Function capabilities returned from pizlonated getters are never offset</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/21">Issue 21: Implement Fil-C's unwinding in terms of native unwinding</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/22">Issue 22: The Fil-C calling convention should be optimized</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/23">Issue 23: Turn malloc calls into direct calls into the GC allocator</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/24">Issue 24: LLVM does a bad job of register allocation for origins</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/25">Issue 25: Optimize pollchecks</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/26">Issue 26: Emitting a is-not-free check instead of an upper bounds check is often a pessimization</a></p></li>
<li><p><a href="https://github.com/pizlonator/fil-c/issues/27">Issue 27: Slow path calls to the runtime should use a calling convention that preserves all (or most) registers</a></p></li>
</ul>
        </main>
    </div>
</body>
</html>
